<!doctype html><html lang=zh-cn><head><meta name=generator content="Hugo 0.81.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>arvin's blog</title><meta name=Description content><meta property="og:title" content="arvin's blog"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://wzliy.github.io/"><meta name=twitter:card content="summary"><meta name=twitter:title content="arvin's blog"><meta name=twitter:description content><meta name=application-name content="arvin's blog"><meta name=apple-mobile-web-app-title content="arvin's blog"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://wzliy.github.io/><link rel=alternate href=/index.xml type=application/rss+xml title="arvin's blog"><link rel=feed href=/index.xml type=application/rss+xml title="arvin's blog"><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","url":"https:\/\/wzliy.github.io\/","inLanguage":"zh-CN","name":"arvin's blog"}</script></head><body header-desktop header-mobile><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':''==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:''==='dark')&&document.body.setAttribute('theme','dark')</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="arvin's blog">arvin's blog</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="arvin's blog">arvin's blog</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class="page home" posts><div class=home-profile></div><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/>面试记录</a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>arvin</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=2021-04-13>2021-04-13</time></span></div><div class=content>面试遇到问题记录
Spring Boot与Spring Cloud的区别 Spring Cloud的组成 怎么识别哪些数据需要缓存到Redis Maven怎么解决依赖冲突 如何优化Sql Mysql索引的数据结构 Mysql索引有什么缺点(比如一张表有十个字段，给十个字段都建立索引有什么问题) 分库如何查询的 多线程怎么使用的 Spring Boot 启动原理
自定义启动类
双亲委派机制
Spring Bean的生命周期
对象创建的过程
垃圾回收算法
自定义类加载器
Redis的哨兵机制
Kafka底层原理
通过索引，怎么查询数据
项目中有没有用到Spring Aop
Spring Aop的实现原理
面试整理 集合 经常用到哪些 Map 这几种 Map 的区别 ConcurrentHashMap 怎么保证线程安全 ConcurrentHashMap 在 JDK 1.</div><div class=post-footer><a href=/posts/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/>阅读全文</a></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/java%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0/>Java并发学习</a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>arvin</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=2021-03-30>2021-03-30</time></span></div><div class=content>软件并发已经成为现代软件开发的基础能力，而Java精心设计的高效并发机制，正是构建大规模应用的基础之一。
并发可以充分发挥多处理器系统的强大计算能力，随着处理器数量的持续增长，如何高效地使用并发正变得越来越重要。
进程与线程 进程 进程使程序的一次执行过程，是系统运行的基本单位，系统运行一个程序的过程即是一个进程从创建、运行到消亡的过程。
早期的计算机中不包含操作系统，它们从头到尾只执行一个程序，并且这个程序能够访问计算机中所有的资源。操作系统的出现使得计算机每次能运行多个程序，并且不同的程序都在单独的进程中运行：操作系统为每个独立执行的进程分配各种资源，包括内存，文件句柄以及安全证书等。如果需要的话，在不同的进程中可以通过一些粗粒度的通信机制来交换数据，包括：套接字、信号处理器、共享内存、信号量以及文件等。
之所以在计算机中加入操作系统来实现多个程序的同时执行，主要基于以下原因：
资源利用率：在某些情况下，程序必须等待某个外部操作执行完成，例如输入输出操作，因此，如果在等待的同时可以运行另一个程序，那么无疑将提高资源利用率。 公平性：不同的用户和程序对于计算机上的资源有着同等的使用权。一种高效的运行的方式时通过粗粒度的时间分片，使这些用户和程序能共享计算机资源。 便利性：通常来说，在计算多个任务时，应该编写多个程序，每个程序执行一个任务并在必要时相互通信，这比只编写一个程序来计算所有任务更容易实现。 线程 线程是比进程更小的执行单位。线程允许在同一个进程中存在多个程序控制流。线程会共享进程范围内的资源，例如内存句柄和文件句柄，但每个线程都有自己的程序计数器、栈以及局部变量等。
线程也被称为轻量级进程。在大多数现代操作系统中，都是以线程为基本的调度单位，而不是进程。如果没有明确的协调机制，那么线程将彼此独立运行。由于同一个进程中所有线程都将共享进程内的内存地址空间，因此这些线程都能访问相同的变量并在同一个堆上分配对象，这就需要实现一种比在进程间共享数据粒度更细的数据共享机制。如果没有明确的同步机制来协同对共享数据的访问，那么当一个线程正在使用某个变量时，另一个线程可能同时访问这个变量，这将造成不可预测的结果。
Java程序天生就是多线程程序：一个Java程序的运行时main线程和多个其他线程同时运行。
线程的优势 线程可以有效降低程序的开发和维护成本，同时提升复杂应用程序的性能。线程能够将大部分的异步工作流转换成串行工作流，因此能更好地模拟人类的工作方式和交互方式。
在GUI应用程序中，线程可以提高用户界面的响应灵敏度，而在服务器应用程序中，可以提升资源利用率以及系统吞吐率。线程还可以简化JVM的实现，垃圾收集器通常在一个或多个专门的线程中运行。在许多重要的Java应用程序中，都在一定程度上用到了线程。
线程带来的风险 安全性问题 活跃性问题 性能问题 线程安全性 并发的核心在于线程安全，什么是线程安全？
线程安全是一个多线程环境下正确性的概念，也就是保证多线程环境下共享的、可修改的状态的正确性。
《Java并发编程实战》
这里的状态可以反映在程序中其实可以看作是数据。换个角度来看，如果状态不是共享的，或者不是可修改的，也就不存在线程安全问题，所以，进而可以推理出保证线程安全的两个办法：封装(将对象内部状态隐藏保护起来，变得不可共享)，不可变（通过final或者immutable使状态不可变）。
线程安全需要保证几个基本特性：
原子性：简单来说就是相关操作不会中途被其他线程干扰，一般可通过同步机制实现。 可见性：一个线程修改了某个共享变量，其他线程可以同步获取修改结果，通常被解释为将线程本地状态反映到主内存上，volatile就是负责保证可见性的。 有序性：保证线程内串行语义，避免指令重排等。 解决原子性问题
原子性问题的源头是线程切换，如果能够禁用线程切换就能从源头解决这个问题，而操作系统做线程切换是依赖cpu中断的，所以禁止CPU发生中断就能够禁止线程切换。在早期的单核CPU时代，这个方案是可行的，但在多核场景下，同一时刻，有可能有两个线程同时执行，此时禁止CPU中断，只能保证CPU上的线程连续执行，并不能保证同一时刻只有一个线程执行。
同一个时刻只有一个线程执行，我们称之为互斥，如果能够保证对共享变量的修改是互斥的，那么，就能够保证原子性了。
互斥锁就是用来解决原子性问题的
锁 受保护资源和锁之间合理的关联关系应该是N:1的关系，也就是说可以用一把锁来保护多个资源，但是不能用多把锁来保护一个资源。
用不同的锁对受保护资源进行精细化管理，能够提升性能。这种锁称为细粒度锁。
synchronized与ReentrantLock synchronized是Java内建的同步机制，它提供了互斥的语义和可见性，当一个线程已经获取当前锁时，其他试图获取的线程只能等待或者阻塞在那里。
ReentrantLock，通常翻译为再入锁，使Java5提供的锁实现。
synchronized
Java编译器会在synchronized修饰的方法或代码块前后自动加上加锁lock()和解锁uncheck()。
如何用一把锁保护多个资源 受保护的资源和锁之间的合理的关联关系应该是N:1的关系
一把锁可以保护多个资源，但不能用多个锁来保护一个资源。
我们可以用一把锁来保护多个资源，但会导致性能太差。用不同的锁对受保护的资源进行精细化管理，能够提升性能，这种锁被叫做细粒度锁。
保护有关联关系的多个资源 如果多个资源是有关联关系的，那么这个问题就比较复杂了。
比如一个银行转账问题，A账户给B账户转账100元，在Account类中有一个transfer()的用于转账的方法。
class Account { private int balance; // 转账 void transfer( Account target, int amt){ if (this.</div><div class=post-footer><a href=/posts/java%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0/>阅读全文</a></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/java%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1/>Java引用对象</a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>arvin</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=2021-03-28>2021-03-28</time></span></div><div class=content>我该如何学会停止担心OutOfMemoryError
Java堆和对象的生命周期 对于一个从C++到Java的新程序员来说，堆和栈之间的关系可能很难掌握。在C++中，可以通过new的操作在堆上创建对象，或者使用"自动"分配在栈上创建对象。以下是合法的C++程序：它在栈上创建了一个新对象。但是，Java编译器将其拒绝为语法报错。
Integer foo = Integer(1); Java不同于C++，Java将所有的对象都存储于堆中，并要求通过new操作来创建对象。局部变量仍存储在栈上，但是它们持有指向对象的指针，而不是对象本身（当然，更多的是使C++程序员困惑，这些指针被称为"引用"）。思考下面的Java方法，该方法具有一个Integer变量，该变量引用一个从String解析的值：
public static void foo(String bar) { Integer baz = new Integer(bar); } 下图显示了此方法的堆和栈之间的关系。栈被分为一个个的栈帧，其中包含调用树中每个方法的参数和局部变量。这些变量都指向了对象(在本例中为参数bar和局部变量baz), 指向了存活在堆中的对象。
现在更仔细的观察foo()的第一行，分配了一个新的Integer对象。在幕后，JVM首先尝试为此对象找到足够的堆空间(在32位的JVM上大概是12字节)。如果能够分配空间，则调用构造器，该构造器解析已通过的字符串并初始化新分配的对象。最后JVM将指向这个对象的指针保存在变量baz中。
这就是"快乐之路"，有几个不太快乐的地方，其中一个就是，我们关心的是当new操作不能为这个对象找到12个字节的空间时怎么处理。在这种情况下，放弃和抛出OutOfMemoryError之前，它将调用垃圾收集器，试图腾出空间。
垃圾收集器 虽然Java提供了一个new操作来分配堆上的对象，但它没有提供相应的操作来删除它们。当foo()方法返回时，变量baz超出了范围，但它指向的对象仍然存在于堆中。如果这是故事的结尾，那么所有的程序都将很快耗尽内存。然而，Java提供了一个垃圾回收器，以便在不再引用这些对象后进行清理。
当程序尝试创建新对象而在堆中没有足够的空间时，垃圾收集器开始工作。请求线程暂停，收集器通过查看堆空间，试图找到不再积极使用的程序对象，并回收其空间。如果收集器无法释放足够的空间，而JVM无法扩展堆，那么new操作将抛出OutOfMemoryError异常。这通常，这之后是你的应用程序关闭。
标记扫描 Java的一个持久神话围绕着垃圾收集器展开。许多人认为，JVM保存了每个对象的引用次数，而收集器只查看引用次数为零的对象。实际上，JVM使用了一种"标记扫描(Mark-sweep)&ldquo;的技术。标记扫描垃圾收集背后的理念很简单：程序无法到达的每个对象都是垃圾，可以进行回收。
标记扫描收集有以下阶段：
第1阶段：标记
垃圾收集器从"root"引用开始，并遍历对象图，标记它到达的所有对象。
第2阶段：扫描
任何在第一阶段未标记的对象都是无法到达的，因此是垃圾对象。如果垃圾对象定义了终结器(fanalizer)，则将其添加到终结器队列(finalization queue)中。如果没有，它的空间可用于重新分配(确切的含义取决于特定的GC实现，并且有许多实现)。
第3阶段：紧凑(可选)
有些垃圾收集器有第三步：压实。在此步骤中，GC将对象移动到合并收集的垃圾留下的自由空间。这个可以防止堆空间碎片化，从而导致大的连续分配失败。
例如，hotspot JVM 在新生代中使用压缩收集器，但在其老年代中使用非压缩收集器(至少在1.6和1.7版本)。
root引用 那么，&ldquo;root"是什么？在一个简单的Java应用程序中，它们是方法参数和局部变量(存储在栈上)，当前执行表达式的操作（也存储在栈上）和静态类成员变量。
在使用自己的类加载器的程序中，含义变得模糊不清：只有被系统类加载器加载的类包含root引用(JVM启动时使用的加载器)。应用程序创建的任何类加载器本身都会受到垃圾收集器的约束，一旦没有更多的引用指向他们。这就是允许应用服务器进行热部署的原因：它们为每个已部署的应用程序创建一个单独的类加载器，并在应用程序未部署或重新部署时放弃类加载器的引用。
了解root引用很重要，因为它定义了什么是"强"引用: 如果你能够遵循从root到特定对象的一系列引用，则该对象被"强烈"引用。它不会被垃圾回收。
因此，回到foo()方法，bar参数和baz局部变量只有在方法执行时才具有强引用，一旦方法完成，它们都将超出范围，并且所引用的对象也可以进行收集。另外，foo()方法可能会返回一个它创建的Integer引用，这意味着该对象仍将被调用foo()的方法强烈引用。
现在考虑以下事项：
LinkedList foo = new LinkedList(); foo.add(new Integer(123)); 变量foo是一个指向LinkList对象的root引用。linked list里面有零个或多个列表元素，每个元素都指向其后续内容。当我们调用add()方法时，我们添加了一个新的list元素，并且该list元素指向一个值为123的实例。这是一个强的引用链，这意味着该Integer对象不符合收集条件。然而，一旦foo 超出了范围，LinkedList和它其中的所有内容都可以进行收集&ndash;当然，前提是没有其他的强引用指向它。
你可能想知道，如果你有一个循环引用，会发生什么情况：对象A包含对对象B的引用，对象B包含对A的引用。答案是，标记扫描收集器不会被愚弄：如果A和B都无法通过一系列的强引用到达，那么他们都能够被收集。
Finalizers C++允许对象定义一个清理方法：当对象脱离了作用域或被明确删除时，这个清理方法被调用用来清理其使用的资源。对于大多数对象，这意味着显式释放通过new或者malloc分配对象的任何内存。在Java中，垃圾收集器为你清理内存，因此无需明确的清理方法来处理此操作。
但是内存并不是唯一的需要清理的资源。想想FileOutputStream: 当你创建这个对象的实例的时候，它会从操作系统分配文件句柄。如果你在关闭流之前让流的所有引用都退出作用域，该文件句柄会发生什么情况呢？答案是，流有一个Finalizer 方法：在垃圾收集器回收对象之前调用的一个方法。在这个FileOutputStream的例子中，finalizer方法关闭流，将文件句柄释放回操作系统，并冲洗任何缓冲区，确保所有数据都正确地写入磁盘。
任何对象都可以有finalizers: 你所需要做的就是声明finalize() 方法：
protected void finalize() throws Throwable { // cleanup your object here } 虽然finalizers似乎是一种清理自己的简单方法，但是，它们确实存在一些严重的局限性。首先，你不应该依赖他们来处理任何重要的事情，因为对象的finalizers可能永远不会被调用&ndash;应用程序可能在对象有资格进行垃圾回收之前退出。finalizers还有一些其他的更微妙的问题，稍后我们会在幻象引用的时候来讨论它。</div><div class=post-footer><a href=/posts/java%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1/>阅读全文</a></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/>引用类型</a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>arvin</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=2021-03-28>2021-03-28</time></span></div><div class=content>Java的引用类型分为四种：强引用，弱引用，软引用，幻象引用。</div><div class=post-footer><a href=/posts/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/>阅读全文</a></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/docker/></a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>作者</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=0001-01-01>0001-01-01</time></span></div><div class=content>Docker Compose Compose项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。
定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）。</div><div class=post-footer><a href=/posts/docker/>阅读全文</a></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/kafka%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/></a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>作者</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=0001-01-01>0001-01-01</time></span></div><div class=content>Kafka入门 Kafka的概念与术语 主题（Topic）
发布订阅的对象是主题。你可以为每个业务、每个应用甚至是每类数据都创建专属的主题。
生产者（Producer）
向主题发布消息的客户端应用程序称为生产者（Producer），生产者程序通常持续不断地向一个或多个主题发送消息。
消费者（Consumer）
订阅这些主题消息的客户端应用程序就被称为消费者。消费者也能够同时订阅多个主题的消息。
我们把生产者和消费者统称为客户端（Clients）。你可以同时运行多个生产者和消费者实例，这些实例会不断地向 Kafka 集群中的多个主题生产和消费消息。
Broker
Kafka 的服务器端由被称为 Broker 的服务进程构成，即一个 Kafka 集群由多个 Broker 组成，Broker 负责接收和处理客户端发送过来的请求，以及对消息进行持久化。
虽然多个 Broker 进程能够运行在同一台机器上，但更常见的做法是将不同的 Broker 分散运行在不同的机器上，这样如果集群中某一台机器宕机，即使在它上面运行的所有 Broker 进程都挂掉了，其他机器上的 Broker 也依然能够对外提供服务。这其实就是 Kafka 提供高可用的手段之一。
备份机制
实现高可用的另一个手段就是备份机制（Replication）。备份的思想很简单，就是把相同的数据拷贝到多台机器上，而这些相同的数据拷贝在 Kafka 中被称为副本（Replica）。
Kafka 定义了两类副本：领导者副本（Leader Replica）和追随者副本（Follower Replica）。前者对外提供服务，这里的对外指的是与客户端程序进行交互；而后者只是被动地追随领导者副本而已，不能与外界进行交互。
副本的工作机制很简单：生产者总是向领导者副本写消息；而消费者总是从领导者副本读消息。至于追随者副本，它只做一件事：就是向领导者副本发送请求，请求领导者把最新生产的消息发给它，这样它能保持与领导者同步。
分区
虽然有了副本机制可以保证数据的持久化或消息不丢失，但没有解决伸缩性的问题。为了解决这个问题，Kafka设计了分区机制。Kafka 中的分区机制指的是将每个主题划分成多个分区（Partition），每个分区是一组有序的消息日志。生产者生产的每条消息只会被发送到一个分区中，也就是说如果向一个双分区的主题发送一条消息，这条消息要么在分区 0 中，要么在分区 1 中。如你所见，Kafka 的分区编号是从 0 开始的，如果 Topic 有 100 个分区，那么它们的分区号就是从 0 到 99。</div><div class=post-footer><a href=/posts/kafka%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/>阅读全文</a></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/leetcode%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/></a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>作者</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=0001-01-01>0001-01-01</time></span></div><div class=content>数组 1011. 在 D 天内送达包裹的能力 题目描述
传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。
传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。
返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力。
解题思路
我们先确定船的运载能力在整个包裹最小值，与所有包裹总重量之间，通过二分查找法，找到最终的最低运载能力，因为我们能这样判断：存在一个最低的运载能力，大于这个能力的，一定也可以在D天内送完所有包裹，小于这个能力的，无法在D天内运送完这个包裹。
我们还要解决一个判定问题：怎么判断这个运载能力可以在D天内运送完所有包裹？这个可以使用贪心的方法解决：
由于我们必须按照数组weights 中包裹的顺序进行运送，因此我们从数组weights 的首元素开始遍历，将连续的包裹都安排在同一天进行运送。当这批包裹的重量大于运载能力 xx 时，我们就需要将最后一个包裹拿出来，安排在新的一天，并继续往下遍历。当我们遍历完整个数组后，就得到了最少需要运送的天数。
class Solution { public int shipWithinDays(int[] weights, int D) { // 确定二分查找的左右边界 int left = Arrays.stream(weights).max().getAsInt(); int right = left * weights.length / D + 1; while (left &lt; right) { int mid = (left + right) / 2; int cur = 0; int need = 1; // 以当前mid的运载能力需要运送的天数， for (int weight : weights) { // 如果当前所有重量加上现在的重量 > mid运载能力，就需要+1天 if (cur+weight > mid) { cur = weight; ++need; } else { cur += weight; } } // 如果计算出的天数 &lt;= D, 意味着当前运载能力还可以减少，需要将抛弃右半边，right = mid if (need &lt;= D) { right = mid; } else { left = mid + 1; } } return left; } } 链表 147.</div><div class=post-footer><a href=/posts/leetcode%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/>阅读全文</a></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/mysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%AE%9E%E6%88%98/></a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>作者</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=0001-01-01>0001-01-01</time></span></div><div class=content>1. 拉取mysql docker 镜像
docker pull mysql
2. docker 文件编排
使用docker-compose进行配置文件的编排
version:'3'services:mysql-master:image:mysqlcontainer_name:mysql-masterenvironment:- MYSQL_ROOT_PASSWORD=rootports:- "3307:3306"volumes:- "./mysql/master/my.cnf:/etc/my.cnf"- "./mysql/master/data:/var/lib/mysql"links:- mysql-slavemysql-slave:image:mysql:5.7container_name:mysql-slaveenvironment:- MYSQL_ROOT_PASSWORD=rootports:- "3308:3306"volumes:- "./mysql/slave/my.cnf:/etc/my.cnf"- "./mysql/slave/data:/var/lib/mysql"docker-compose配置解释
services：服务，相当于启动一个docker容器
image：docker镜像名
container_name：docker容器启动后的名字
environment：环境变量
ports：端口映射 ：主机端口：容器内端口
volumes：挂载目录 主机内目录:容器内目录
启动docker-compose
docker-compose -f docker-compose-mysql.yml up -d</div><div class=post-footer><a href=/posts/mysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%AE%9E%E6%88%98/>阅读全文</a></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/spring-cloud-gateway/></a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>作者</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=0001-01-01>0001-01-01</time></span></div><div class=content>编写Spring Cloud Gateway
该项目提供了一个用于在Spring WebFlux之上构建API网关的库。Spring Cloud Gateway旨在提供一种简单而有效的方法来路由到API，并为它们提供跨领域关注，例如：安全性，监视/指标和弹性。
创建gateway微服务
引入依赖
要将Spring Cloud Gateway包含在您的项目中，请使用groupId为org.springframework.cloud的启动程序，以及artifact ID为spring-cloud-starter-gateway的工件。
&lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-gateway&lt;/artifactId> &lt;/dependency> 如果你引入了依赖，但你不希望启用网关，设置 spring.cloud.gateway.enabled=false.
注意：
Spring Cloud Gateway 构建在Spring Boot 2.x, Spring WebFlux, 和 Project Reactor上。导致的结果，当你使用Spring Cloud Gateway时，许多你熟悉的同步库（例如，Spring Data和Spring Security）和模式可能不适用。
Spring Cloud Gateway需要Spring Boot和Spring Webflux提供的Netty运行支持。它在传统的Servlet容器中或作为WAR构建时不起作用。
编写配置
server:port:8040spring:application:name:gatewaycloud:nacos:discovery:server-addr:localhost:8848gateway:discovery:locator:enabled:truemanagement:endpoints:web:exposure:inclue:'*'endpoint:health:show-details:always 术语和概念
Route：网关的基本构建块。它由ID，目标URI，谓词集合和过滤器集合定义。如果聚合谓词为true，则匹配路由。
Predicate：这是Java 8函数谓词。输入类型是Spring Framework （ServerWebExchange）。这使你可以匹配HTTP请求中的所有内容，例如请求头或参数。
Filter：这些是已通过特定工厂构造的GatewayFilter实例。在这里，你可以在发送下游请求之前或之后修改请求和响应。</div><div class=post-footer><a href=/posts/spring-cloud-gateway/>阅读全文</a></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/staffjoy%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/></a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>作者</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=0001-01-01>0001-01-01</time></span></div><div class=content>课程目标和主要内容
掌握微服务架构和前后分离架构 掌握基于Spring Boot搭建微服务基础框架 进一步提升Java/Spring微服务开发技能 掌握Spring Boot微服务测试和相关实践 理解SaaS多租户应用的架构和设计 理解可运维架构理念和相关实践 掌握服务容器化和容器云部署相关实践 理解云时代的软件工程流程和实践 Staffjoy应用需求
功能
管理员Admin管理公司和排班
雇员Worker管理个人信息
非功能
Saas + 定制部署
一键部署到Kubernetes容器云
营销和客服友好
系统总体架构
账户数据模型
账户接口
微服务接口参数校验
统一异常处理
DTO和DMO互转
使用ModelMapper
强类型接口
GRPC属于强类型，SpringBoot属于弱类型
如何设计一个最简网关
网关的主要原理就是拦截url请求，进行统一处理
我们可以先设置一个拦截器：继承OncePerRequestFilter
@Slf4j public class ReverseProxyFilter extends OncePerRequestFilter { protected final RequestDataExtractor extractor; public ReverseProxyFilter(RequestDataExtractor extractor) { this.extractor = extractor; } @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { String originUri = extractor.</div><div class=post-footer><a href=/posts/staffjoy%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/>阅读全文</a></div></article><ul class=pagination><li class=page-item><span class=page-link><a href=/>1</a></span></li><li class="page-item active"><span class=page-link><a href=/page/2/>2</a></span></li><li class=page-item><span class=page-link><a href=/page/3/>3</a></span></li></ul></div></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.81.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i>LoveIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2021</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank></a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i></a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>