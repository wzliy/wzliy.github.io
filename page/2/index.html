<!doctype html><html lang=zh-cn><head><meta name=generator content="Hugo 0.81.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>arvin's blog</title><meta name=Description content><meta property="og:title" content="arvin's blog"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://wzliy.github.io/"><meta name=twitter:card content="summary"><meta name=twitter:title content="arvin's blog"><meta name=twitter:description content><meta name=application-name content="arvin's blog"><meta name=apple-mobile-web-app-title content="arvin's blog"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://wzliy.github.io/><link rel=alternate href=/index.xml type=application/rss+xml title="arvin's blog"><link rel=feed href=/index.xml type=application/rss+xml title="arvin's blog"><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","url":"https:\/\/wzliy.github.io\/","inLanguage":"zh-CN","name":"arvin's blog"}</script></head><body header-desktop header-mobile><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':''==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:''==='dark')&&document.body.setAttribute('theme','dark')</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="arvin's blog">arvin's blog</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="arvin's blog">arvin's blog</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class="page home" posts><div class=home-profile></div><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/>面试记录</a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>arvin</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=2021-04-13>2021-04-13</time></span></div><div class=content>面试遇到问题记录
Spring Boot与Spring Cloud的区别 Spring Cloud的组成 怎么识别哪些数据需要缓存到Redis Maven怎么解决依赖冲突 如何优化Sql Mysql索引的数据结构 Mysql索引有什么缺点(比如一张表有十个字段，给十个字段都建立索引有什么问题) 分库如何查询的 多线程怎么使用的 Spring Boot 启动原理
自定义启动类
双亲委派机制
Spring Bean的生命周期
对象创建的过程
垃圾回收算法
自定义类加载器
Redis的哨兵机制
Kafka底层原理
通过索引，怎么查询数据
项目中有没有用到Spring Aop
Spring Aop的实现原理
面试整理 集合 经常用到哪些 Map 这几种 Map 的区别 ConcurrentHashMap 怎么保证线程安全 ConcurrentHashMap 在 JDK 1.</div><div class=post-footer><a href=/posts/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/>阅读全文</a></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/java%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0/>Java并发学习</a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>arvin</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=2021-03-30>2021-03-30</time></span></div><div class=content>软件并发已经成为现代软件开发的基础能力，而Java精心设计的高效并发机制，正是构建大规模应用的基础之一。
并发可以充分发挥多处理器系统的强大计算能力，随着处理器数量的持续增长，如何高效地使用并发正变得越来越重要。
进程与线程 进程 进程使程序的一次执行过程，是系统运行的基本单位，系统运行一个程序的过程即是一个进程从创建、运行到消亡的过程。
早期的计算机中不包含操作系统，它们从头到尾只执行一个程序，并且这个程序能够访问计算机中所有的资源。操作系统的出现使得计算机每次能运行多个程序，并且不同的程序都在单独的进程中运行：操作系统为每个独立执行的进程分配各种资源，包括内存，文件句柄以及安全证书等。如果需要的话，在不同的进程中可以通过一些粗粒度的通信机制来交换数据，包括：套接字、信号处理器、共享内存、信号量以及文件等。
之所以在计算机中加入操作系统来实现多个程序的同时执行，主要基于以下原因：
资源利用率：在某些情况下，程序必须等待某个外部操作执行完成，例如输入输出操作，因此，如果在等待的同时可以运行另一个程序，那么无疑将提高资源利用率。 公平性：不同的用户和程序对于计算机上的资源有着同等的使用权。一种高效的运行的方式时通过粗粒度的时间分片，使这些用户和程序能共享计算机资源。 便利性：通常来说，在计算多个任务时，应该编写多个程序，每个程序执行一个任务并在必要时相互通信，这比只编写一个程序来计算所有任务更容易实现。 线程 线程是比进程更小的执行单位。线程允许在同一个进程中存在多个程序控制流。线程会共享进程范围内的资源，例如内存句柄和文件句柄，但每个线程都有自己的程序计数器、栈以及局部变量等。
线程也被称为轻量级进程。在大多数现代操作系统中，都是以线程为基本的调度单位，而不是进程。如果没有明确的协调机制，那么线程将彼此独立运行。由于同一个进程中所有线程都将共享进程内的内存地址空间，因此这些线程都能访问相同的变量并在同一个堆上分配对象，这就需要实现一种比在进程间共享数据粒度更细的数据共享机制。如果没有明确的同步机制来协同对共享数据的访问，那么当一个线程正在使用某个变量时，另一个线程可能同时访问这个变量，这将造成不可预测的结果。
Java程序天生就是多线程程序：一个Java程序的运行时main线程和多个其他线程同时运行。
线程的优势 线程可以有效降低程序的开发和维护成本，同时提升复杂应用程序的性能。线程能够将大部分的异步工作流转换成串行工作流，因此能更好地模拟人类的工作方式和交互方式。
在GUI应用程序中，线程可以提高用户界面的响应灵敏度，而在服务器应用程序中，可以提升资源利用率以及系统吞吐率。线程还可以简化JVM的实现，垃圾收集器通常在一个或多个专门的线程中运行。在许多重要的Java应用程序中，都在一定程度上用到了线程。
线程带来的风险 安全性问题 活跃性问题 性能问题 线程安全性 并发的核心在于线程安全，什么是线程安全？
线程安全是一个多线程环境下正确性的概念，也就是保证多线程环境下共享的、可修改的状态的正确性。
《Java并发编程实战》
这里的状态可以反映在程序中其实可以看作是数据。换个角度来看，如果状态不是共享的，或者不是可修改的，也就不存在线程安全问题，所以，进而可以推理出保证线程安全的两个办法：封装(将对象内部状态隐藏保护起来，变得不可共享)，不可变（通过final或者immutable使状态不可变）。
线程安全需要保证几个基本特性：
原子性：简单来说就是相关操作不会中途被其他线程干扰，一般可通过同步机制实现。 可见性：一个线程修改了某个共享变量，其他线程可以同步获取修改结果，通常被解释为将线程本地状态反映到主内存上，volatile就是负责保证可见性的。 有序性：保证线程内串行语义，避免指令重排等。 解决原子性问题
原子性问题的源头是线程切换，如果能够禁用线程切换就能从源头解决这个问题，而操作系统做线程切换是依赖cpu中断的，所以禁止CPU发生中断就能够禁止线程切换。在早期的单核CPU时代，这个方案是可行的，但在多核场景下，同一时刻，有可能有两个线程同时执行，此时禁止CPU中断，只能保证CPU上的线程连续执行，并不能保证同一时刻只有一个线程执行。
同一个时刻只有一个线程执行，我们称之为互斥，如果能够保证对共享变量的修改是互斥的，那么，就能够保证原子性了。
互斥锁就是用来解决原子性问题的
锁 受保护资源和锁之间合理的关联关系应该是N:1的关系，也就是说可以用一把锁来保护多个资源，但是不能用多把锁来保护一个资源。
用不同的锁对受保护资源进行精细化管理，能够提升性能。这种锁称为细粒度锁。
synchronized与ReentrantLock synchronized是Java内建的同步机制，它提供了互斥的语义和可见性，当一个线程已经获取当前锁时，其他试图获取的线程只能等待或者阻塞在那里。
ReentrantLock，通常翻译为再入锁，使Java5提供的锁实现。
synchronized
Java编译器会在synchronized修饰的方法或代码块前后自动加上加锁lock()和解锁uncheck()。
如何用一把锁保护多个资源 受保护的资源和锁之间的合理的关联关系应该是N:1的关系
一把锁可以保护多个资源，但不能用多个锁来保护一个资源。
我们可以用一把锁来保护多个资源，但会导致性能太差。用不同的锁对受保护的资源进行精细化管理，能够提升性能，这种锁被叫做细粒度锁。
保护有关联关系的多个资源 如果多个资源是有关联关系的，那么这个问题就比较复杂了。
比如一个银行转账问题，A账户给B账户转账100元，在Account类中有一个transfer()的用于转账的方法。
class Account { private int balance; // 转账 void transfer( Account target, int amt){ if (this.</div><div class=post-footer><a href=/posts/java%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0/>阅读全文</a></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/java%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1/>Java引用对象</a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>arvin</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=2021-03-28>2021-03-28</time></span></div><div class=content>我该如何学会停止担心OutOfMemoryError
Java堆和对象的生命周期 对于一个从C++到Java的新程序员来说，堆和栈之间的关系可能很难掌握。在C++中，可以通过new的操作在堆上创建对象，或者使用"自动"分配在栈上创建对象。以下是合法的C++程序：它在栈上创建了一个新对象。但是，Java编译器将其拒绝为语法报错。
Integer foo = Integer(1); Java不同于C++，Java将所有的对象都存储于堆中，并要求通过new操作来创建对象。局部变量仍存储在栈上，但是它们持有指向对象的指针，而不是对象本身（当然，更多的是使C++程序员困惑，这些指针被称为"引用"）。思考下面的Java方法，该方法具有一个Integer变量，该变量引用一个从String解析的值：
public static void foo(String bar) { Integer baz = new Integer(bar); } 下图显示了此方法的堆和栈之间的关系。栈被分为一个个的栈帧，其中包含调用树中每个方法的参数和局部变量。这些变量都指向了对象(在本例中为参数bar和局部变量baz), 指向了存活在堆中的对象。
现在更仔细的观察foo()的第一行，分配了一个新的Integer对象。在幕后，JVM首先尝试为此对象找到足够的堆空间(在32位的JVM上大概是12字节)。如果能够分配空间，则调用构造器，该构造器解析已通过的字符串并初始化新分配的对象。最后JVM将指向这个对象的指针保存在变量baz中。
这就是"快乐之路"，有几个不太快乐的地方，其中一个就是，我们关心的是当new操作不能为这个对象找到12个字节的空间时怎么处理。在这种情况下，放弃和抛出OutOfMemoryError之前，它将调用垃圾收集器，试图腾出空间。
垃圾收集器 虽然Java提供了一个new操作来分配堆上的对象，但它没有提供相应的操作来删除它们。当foo()方法返回时，变量baz超出了范围，但它指向的对象仍然存在于堆中。如果这是故事的结尾，那么所有的程序都将很快耗尽内存。然而，Java提供了一个垃圾回收器，以便在不再引用这些对象后进行清理。
当程序尝试创建新对象而在堆中没有足够的空间时，垃圾收集器开始工作。请求线程暂停，收集器通过查看堆空间，试图找到不再积极使用的程序对象，并回收其空间。如果收集器无法释放足够的空间，而JVM无法扩展堆，那么new操作将抛出OutOfMemoryError异常。这通常，这之后是你的应用程序关闭。
标记扫描 Java的一个持久神话围绕着垃圾收集器展开。许多人认为，JVM保存了每个对象的引用次数，而收集器只查看引用次数为零的对象。实际上，JVM使用了一种"标记扫描(Mark-sweep)&ldquo;的技术。标记扫描垃圾收集背后的理念很简单：程序无法到达的每个对象都是垃圾，可以进行回收。
标记扫描收集有以下阶段：
第1阶段：标记
垃圾收集器从"root"引用开始，并遍历对象图，标记它到达的所有对象。
第2阶段：扫描
任何在第一阶段未标记的对象都是无法到达的，因此是垃圾对象。如果垃圾对象定义了终结器(fanalizer)，则将其添加到终结器队列(finalization queue)中。如果没有，它的空间可用于重新分配(确切的含义取决于特定的GC实现，并且有许多实现)。
第3阶段：紧凑(可选)
有些垃圾收集器有第三步：压实。在此步骤中，GC将对象移动到合并收集的垃圾留下的自由空间。这个可以防止堆空间碎片化，从而导致大的连续分配失败。
例如，hotspot JVM 在新生代中使用压缩收集器，但在其老年代中使用非压缩收集器(至少在1.6和1.7版本)。
root引用 那么，&ldquo;root"是什么？在一个简单的Java应用程序中，它们是方法参数和局部变量(存储在栈上)，当前执行表达式的操作（也存储在栈上）和静态类成员变量。
在使用自己的类加载器的程序中，含义变得模糊不清：只有被系统类加载器加载的类包含root引用(JVM启动时使用的加载器)。应用程序创建的任何类加载器本身都会受到垃圾收集器的约束，一旦没有更多的引用指向他们。这就是允许应用服务器进行热部署的原因：它们为每个已部署的应用程序创建一个单独的类加载器，并在应用程序未部署或重新部署时放弃类加载器的引用。
了解root引用很重要，因为它定义了什么是"强"引用: 如果你能够遵循从root到特定对象的一系列引用，则该对象被"强烈"引用。它不会被垃圾回收。
因此，回到foo()方法，bar参数和baz局部变量只有在方法执行时才具有强引用，一旦方法完成，它们都将超出范围，并且所引用的对象也可以进行收集。另外，foo()方法可能会返回一个它创建的Integer引用，这意味着该对象仍将被调用foo()的方法强烈引用。
现在考虑以下事项：
LinkedList foo = new LinkedList(); foo.add(new Integer(123)); 变量foo是一个指向LinkList对象的root引用。linked list里面有零个或多个列表元素，每个元素都指向其后续内容。当我们调用add()方法时，我们添加了一个新的list元素，并且该list元素指向一个值为123的实例。这是一个强的引用链，这意味着该Integer对象不符合收集条件。然而，一旦foo 超出了范围，LinkedList和它其中的所有内容都可以进行收集&ndash;当然，前提是没有其他的强引用指向它。
你可能想知道，如果你有一个循环引用，会发生什么情况：对象A包含对对象B的引用，对象B包含对A的引用。答案是，标记扫描收集器不会被愚弄：如果A和B都无法通过一系列的强引用到达，那么他们都能够被收集。
Finalizers C++允许对象定义一个清理方法：当对象脱离了作用域或被明确删除时，这个清理方法被调用用来清理其使用的资源。对于大多数对象，这意味着显式释放通过new或者malloc分配对象的任何内存。在Java中，垃圾收集器为你清理内存，因此无需明确的清理方法来处理此操作。
但是内存并不是唯一的需要清理的资源。想想FileOutputStream: 当你创建这个对象的实例的时候，它会从操作系统分配文件句柄。如果你在关闭流之前让流的所有引用都退出作用域，该文件句柄会发生什么情况呢？答案是，流有一个Finalizer 方法：在垃圾收集器回收对象之前调用的一个方法。在这个FileOutputStream的例子中，finalizer方法关闭流，将文件句柄释放回操作系统，并冲洗任何缓冲区，确保所有数据都正确地写入磁盘。
任何对象都可以有finalizers: 你所需要做的就是声明finalize() 方法：
protected void finalize() throws Throwable { // cleanup your object here } 虽然finalizers似乎是一种清理自己的简单方法，但是，它们确实存在一些严重的局限性。首先，你不应该依赖他们来处理任何重要的事情，因为对象的finalizers可能永远不会被调用&ndash;应用程序可能在对象有资格进行垃圾回收之前退出。finalizers还有一些其他的更微妙的问题，稍后我们会在幻象引用的时候来讨论它。</div><div class=post-footer><a href=/posts/java%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1/>阅读全文</a></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/>引用类型</a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>arvin</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=2021-03-28>2021-03-28</time></span></div><div class=content>Java的引用类型分为四种：强引用，弱引用，软引用，幻象引用。</div><div class=post-footer><a href=/posts/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/>阅读全文</a></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/kafka%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/></a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>作者</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=0001-01-01>0001-01-01</time></span></div><div class=content>Kafka入门 Kafka的概念与术语 主题（Topic）
发布订阅的对象是主题。你可以为每个业务、每个应用甚至是每类数据都创建专属的主题。
生产者（Producer）
向主题发布消息的客户端应用程序称为生产者（Producer），生产者程序通常持续不断地向一个或多个主题发送消息。
消费者（Consumer）
订阅这些主题消息的客户端应用程序就被称为消费者。消费者也能够同时订阅多个主题的消息。
我们把生产者和消费者统称为客户端（Clients）。你可以同时运行多个生产者和消费者实例，这些实例会不断地向 Kafka 集群中的多个主题生产和消费消息。
Broker
Kafka 的服务器端由被称为 Broker 的服务进程构成，即一个 Kafka 集群由多个 Broker 组成，Broker 负责接收和处理客户端发送过来的请求，以及对消息进行持久化。
虽然多个 Broker 进程能够运行在同一台机器上，但更常见的做法是将不同的 Broker 分散运行在不同的机器上，这样如果集群中某一台机器宕机，即使在它上面运行的所有 Broker 进程都挂掉了，其他机器上的 Broker 也依然能够对外提供服务。这其实就是 Kafka 提供高可用的手段之一。
备份机制
实现高可用的另一个手段就是备份机制（Replication）。备份的思想很简单，就是把相同的数据拷贝到多台机器上，而这些相同的数据拷贝在 Kafka 中被称为副本（Replica）。
Kafka 定义了两类副本：领导者副本（Leader Replica）和追随者副本（Follower Replica）。前者对外提供服务，这里的对外指的是与客户端程序进行交互；而后者只是被动地追随领导者副本而已，不能与外界进行交互。
副本的工作机制很简单：生产者总是向领导者副本写消息；而消费者总是从领导者副本读消息。至于追随者副本，它只做一件事：就是向领导者副本发送请求，请求领导者把最新生产的消息发给它，这样它能保持与领导者同步。
分区
虽然有了副本机制可以保证数据的持久化或消息不丢失，但没有解决伸缩性的问题。为了解决这个问题，Kafka设计了分区机制。Kafka 中的分区机制指的是将每个主题划分成多个分区（Partition），每个分区是一组有序的消息日志。生产者生产的每条消息只会被发送到一个分区中，也就是说如果向一个双分区的主题发送一条消息，这条消息要么在分区 0 中，要么在分区 1 中。如你所见，Kafka 的分区编号是从 0 开始的，如果 Topic 有 100 个分区，那么它们的分区号就是从 0 到 99。</div><div class=post-footer><a href=/posts/kafka%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/>阅读全文</a></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/zookeeper%E5%AD%A6%E4%B9%A0/></a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>作者</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=0001-01-01>0001-01-01</time></span></div><div class=content>Zookeeper zookeeper是针对分布式应用程序的高性能协调服务。它在一个简单的接口中提供了通用的服务-比如naming，configuration management，synchronization，group service，因此，你不必从头开始编写它们。你可以现成使用它来实现共识，组管理，领导者选举和状态协议。你也可以根据自己的特定需求在此基础上构建。
Zookeeper的典型应用场景：
配置管理 DNS服务 组成员管理(group membership) 各种分布式锁 Zookeeper适用于存储和协同相关的关键数据，不适合用于大数据量存储。
概述 Zookeeper：分布式应用程序的分布式协调服务 Zookeeper是一个分布式的，开源的协调服务，用于分布式应用程序，它提供了一组简单的原语，分布式应用程序可以基于这些原语来实现用于同步，配置维护以及组和命名空间的更高级别的服务。它被设计成易于编程的，并使用了按照文件系统熟悉的目录树结构样式设置的数据模型。它以Java运行，并且具有Java和C的绑定。
众所周知，协调服务很难做到。它们特别容易出现诸如竞态条件和死锁之类的错误。Zookeeper背后的动机是减轻分布式应用程序从头开始实施协调服务的责任。
设计目标 Zookeeper是一个开源的分布式协调服务系统。Zookeeper的设计目标是将那些复杂且容易出错的分布式协同服务封装起来，抽象出一个高效可靠的原语集，并以一系列简单的接口提供给用户使用。
ZooKeeper 是简单的。Zookeeper允许分布式进程通过共享的分层名称空间相互协调，该命名空间的组织方式类似于标准文件系统。命名空间由数据寄存器组成（Zookeeper中叫znode）组成，它们类似于文件和目录。与设计用于存储的典型文件系统不同，Zookeeper数据保留在内存中，这意味着Zookeeper可以实现高吞吐量和低延迟数。
Zookeeper的实现重视高性能、高可用、严格有序访问。Zookeeper的性能方面意味着它可以在大型的分布式系统中使用。可靠性方面使它不会成为单点故障。严格的有序意味着可以在客户端上实现复杂的同步原语。
Zookeeper是可复制的。像它协调的分布式进程一样，Zookeeper本身也可以在称为集群的一组主机上进行复制。
组成Zookeeper服务的服务器都必须知道彼此。它们维护内存中的状态图像，以及持久化存储中的事务日志和快照。只要大多数服务器可用，Zookeeper服务将可用。
客户端连接到单个Zookeeper服务器。客户端维护一个TCP连接，通过该连接发送请求，获取响应，获取监视事件并发送心跳。如果与服务器的TCP连接断开，则客户端将连接到其他服务器。
Zookeeper是有序的。Zookeeper用一个反映所有Zookeeper事务顺序的数字标记每个更新。后续操作可以使用该命令来实现更高级别的抽象，例如同步原语。
Zookeeper是快速的。在"读取为主"的工作负载中，它特别快。Zookeeper应用程序可在数千台计算机上运行，并且在读取比写入更常见的情况下以10：1的比率运行效果最佳。
Zookeeper数据模型 Zookeeper提供的命名空间与标准文件系统的名称空间非常相似。名称是由斜杆（/）分隔的一系列路径元素。Zookeeper命名空间中的每个节点都由路径标识。
Zookeeper的数据模型是层次模型。层次模型常见于文件系统。层次模型和key-value模型是两种主流的数据模型。Zookeeper使用文件系统模型主要基于以下两点考虑：
文件系统的树形结构便于表达数据之间的层次关系； 文件系统的树形结构便于为不同的应用分配独立的命名空间(namespace)； Zookeeper的层次模型称为data tree。Data tree的每个节点叫做znode.不同于文件系统，每个节点都可以保存数据，每个节点都有一个版本，版本从0开始计数。
节点和瞬时节点 与标准文件系统不同，Zookeeper命名空间中的每个节点都可以具有与其关联的数据以及子节点。就像拥有一个文件系统一样，该文件系统也允许文件成为目录。（Zookeeper旨在存储协调数据：状态信息、配置、位置信息等，因此存储在每个节点上的数据通常很小，在千字节范围内。）我们使用术语znode来明确表示我们正在谈论Zookeeper数据节点。
Znodes维护一个统计信息结构，其中包括用于数据更改，ACL更改和时间戳的版本号，以允许进行缓存验证和协调更新。znode的数据每次更改时，版本号都会增加。例如，每当客户端检索数据时，它也接收数据的版本。
读取和写入存储在名称空间中每个znode上的数据都是原子操作。读取将获取与znode关联的所有数据字节，而写入将替换所有数据。每个节点都有一个访问控制列表（ACL），用于限制谁可以执行操作。
ZooKeeper还具有瞬时节点的概念。只要创建znode的会话处于活动状态，这些znode就存在。会话结束时，将删除znode。
条件更新和监视器 ZooKeeper支持 监视 的概念。客户端可以在znode上设置监视器。znode更改时，将触发并删除监视。当触发监视后，客户端会收到一个数据包，说明znode已更改。如果客户端与其中一个ZooKeeper服务器之间的连接断开，则客户端将收到本地通知。
3.6.0中的新增功能：客户端还可以在znode上设置永久性的递归监视，这些监视在触发时不会删除，并且会以递归方式触发已注册znode以及所有子znode的更改。
特性 ZooKeeper非常快速且非常简单。但是，由于其目标是作为构建更复杂的服务（例如同步）的基础，因此它提供了一组保证。它们是：
顺序一致性&ndash;来自客户端的更新将按照发送的顺序应用。 原子性&ndash;全部更新成功或失败。没有部分结果。 单个系统映像&ndash;无论客户端连接到哪个服务器，客户端都将看到该服务的相同视图。即，即使客户端故障转移到具有相同会话的其他服务器，客户端也永远不会看到系统的较旧视图。 可靠性&ndash;应用更新后，此更新将一直持续到客户端覆盖更新为止。 及时性&ndash;保证系统的客户视图在特定时间内是最新的。 简单的API ZooKeeper的设计目标之一是提供一个非常简单的编程界面。因此，它仅支持以下操作：
create：在树中的某个位置创建一个节点 delete：删除一个节点 exists：判断某个位置是否存在节点 get data：从节点读取数据 set data：将数据写入节点 get children：检索节点的子级列表 sync：等待数据传播 执行 ZooKeeper组件显示ZooKeeper服务的高级组件。除请求处理器外，构成ZooKeeper服务的每个服务器都复制其自己的每个组件副本。</div><div class=post-footer><a href=/posts/zookeeper%E5%AD%A6%E4%B9%A0/>阅读全文</a></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/></a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>作者</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=0001-01-01>0001-01-01</time></span></div><div class=content>二分图最大匹配 二分图：
int[]</div><div class=post-footer><a href=/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/>阅读全文</a></div></article><ul class=pagination><li class=page-item><span class=page-link><a href=/>1</a></span></li><li class="page-item active"><span class=page-link><a href=/page/2/>2</a></span></li></ul></div></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.81.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i>LoveIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2021</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank></a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i></a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>