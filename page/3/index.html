<!doctype html><html lang=zh-cn><head><meta name=generator content="Hugo 0.81.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>arvin's blog</title><meta name=Description content><meta property="og:title" content="arvin's blog"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://wzliy.github.io/"><meta name=twitter:card content="summary"><meta name=twitter:title content="arvin's blog"><meta name=twitter:description content><meta name=application-name content="arvin's blog"><meta name=apple-mobile-web-app-title content="arvin's blog"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://wzliy.github.io/><link rel=alternate href=/index.xml type=application/rss+xml title="arvin's blog"><link rel=feed href=/index.xml type=application/rss+xml title="arvin's blog"><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","url":"https:\/\/wzliy.github.io\/","inLanguage":"zh-CN","name":"arvin's blog"}</script></head><body header-desktop header-mobile><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':''==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:''==='dark')&&document.body.setAttribute('theme','dark')</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="arvin's blog">arvin's blog</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="arvin's blog">arvin's blog</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class="page home" posts><div class=home-profile></div><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/zookeeper%E5%AD%A6%E4%B9%A0/></a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>作者</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=0001-01-01>0001-01-01</time></span></div><div class=content>Zookeeper zookeeper是针对分布式应用程序的高性能协调服务。它在一个简单的接口中提供了通用的服务-比如naming，configuration management，synchronization，group service，因此，你不必从头开始编写它们。你可以现成使用它来实现共识，组管理，领导者选举和状态协议。你也可以根据自己的特定需求在此基础上构建。
Zookeeper的典型应用场景：
配置管理 DNS服务 组成员管理(group membership) 各种分布式锁 Zookeeper适用于存储和协同相关的关键数据，不适合用于大数据量存储。
概述 Zookeeper：分布式应用程序的分布式协调服务 Zookeeper是一个分布式的，开源的协调服务，用于分布式应用程序，它提供了一组简单的原语，分布式应用程序可以基于这些原语来实现用于同步，配置维护以及组和命名空间的更高级别的服务。它被设计成易于编程的，并使用了按照文件系统熟悉的目录树结构样式设置的数据模型。它以Java运行，并且具有Java和C的绑定。
众所周知，协调服务很难做到。它们特别容易出现诸如竞态条件和死锁之类的错误。Zookeeper背后的动机是减轻分布式应用程序从头开始实施协调服务的责任。
设计目标 Zookeeper是一个开源的分布式协调服务系统。Zookeeper的设计目标是将那些复杂且容易出错的分布式协同服务封装起来，抽象出一个高效可靠的原语集，并以一系列简单的接口提供给用户使用。
ZooKeeper 是简单的。Zookeeper允许分布式进程通过共享的分层名称空间相互协调，该命名空间的组织方式类似于标准文件系统。命名空间由数据寄存器组成（Zookeeper中叫znode）组成，它们类似于文件和目录。与设计用于存储的典型文件系统不同，Zookeeper数据保留在内存中，这意味着Zookeeper可以实现高吞吐量和低延迟数。
Zookeeper的实现重视高性能、高可用、严格有序访问。Zookeeper的性能方面意味着它可以在大型的分布式系统中使用。可靠性方面使它不会成为单点故障。严格的有序意味着可以在客户端上实现复杂的同步原语。
Zookeeper是可复制的。像它协调的分布式进程一样，Zookeeper本身也可以在称为集群的一组主机上进行复制。
组成Zookeeper服务的服务器都必须知道彼此。它们维护内存中的状态图像，以及持久化存储中的事务日志和快照。只要大多数服务器可用，Zookeeper服务将可用。
客户端连接到单个Zookeeper服务器。客户端维护一个TCP连接，通过该连接发送请求，获取响应，获取监视事件并发送心跳。如果与服务器的TCP连接断开，则客户端将连接到其他服务器。
Zookeeper是有序的。Zookeeper用一个反映所有Zookeeper事务顺序的数字标记每个更新。后续操作可以使用该命令来实现更高级别的抽象，例如同步原语。
Zookeeper是快速的。在"读取为主"的工作负载中，它特别快。Zookeeper应用程序可在数千台计算机上运行，并且在读取比写入更常见的情况下以10：1的比率运行效果最佳。
Zookeeper数据模型 Zookeeper提供的命名空间与标准文件系统的名称空间非常相似。名称是由斜杆（/）分隔的一系列路径元素。Zookeeper命名空间中的每个节点都由路径标识。
Zookeeper的数据模型是层次模型。层次模型常见于文件系统。层次模型和key-value模型是两种主流的数据模型。Zookeeper使用文件系统模型主要基于以下两点考虑：
文件系统的树形结构便于表达数据之间的层次关系； 文件系统的树形结构便于为不同的应用分配独立的命名空间(namespace)； Zookeeper的层次模型称为data tree。Data tree的每个节点叫做znode.不同于文件系统，每个节点都可以保存数据，每个节点都有一个版本，版本从0开始计数。
节点和瞬时节点 与标准文件系统不同，Zookeeper命名空间中的每个节点都可以具有与其关联的数据以及子节点。就像拥有一个文件系统一样，该文件系统也允许文件成为目录。（Zookeeper旨在存储协调数据：状态信息、配置、位置信息等，因此存储在每个节点上的数据通常很小，在千字节范围内。）我们使用术语znode来明确表示我们正在谈论Zookeeper数据节点。
Znodes维护一个统计信息结构，其中包括用于数据更改，ACL更改和时间戳的版本号，以允许进行缓存验证和协调更新。znode的数据每次更改时，版本号都会增加。例如，每当客户端检索数据时，它也接收数据的版本。
读取和写入存储在名称空间中每个znode上的数据都是原子操作。读取将获取与znode关联的所有数据字节，而写入将替换所有数据。每个节点都有一个访问控制列表（ACL），用于限制谁可以执行操作。
ZooKeeper还具有瞬时节点的概念。只要创建znode的会话处于活动状态，这些znode就存在。会话结束时，将删除znode。
条件更新和监视器 ZooKeeper支持 监视 的概念。客户端可以在znode上设置监视器。znode更改时，将触发并删除监视。当触发监视后，客户端会收到一个数据包，说明znode已更改。如果客户端与其中一个ZooKeeper服务器之间的连接断开，则客户端将收到本地通知。
3.6.0中的新增功能：客户端还可以在znode上设置永久性的递归监视，这些监视在触发时不会删除，并且会以递归方式触发已注册znode以及所有子znode的更改。
特性 ZooKeeper非常快速且非常简单。但是，由于其目标是作为构建更复杂的服务（例如同步）的基础，因此它提供了一组保证。它们是：
顺序一致性&ndash;来自客户端的更新将按照发送的顺序应用。 原子性&ndash;全部更新成功或失败。没有部分结果。 单个系统映像&ndash;无论客户端连接到哪个服务器，客户端都将看到该服务的相同视图。即，即使客户端故障转移到具有相同会话的其他服务器，客户端也永远不会看到系统的较旧视图。 可靠性&ndash;应用更新后，此更新将一直持续到客户端覆盖更新为止。 及时性&ndash;保证系统的客户视图在特定时间内是最新的。 简单的API ZooKeeper的设计目标之一是提供一个非常简单的编程界面。因此，它仅支持以下操作：
create：在树中的某个位置创建一个节点 delete：删除一个节点 exists：判断某个位置是否存在节点 get data：从节点读取数据 set data：将数据写入节点 get children：检索节点的子级列表 sync：等待数据传播 执行 ZooKeeper组件显示ZooKeeper服务的高级组件。除请求处理器外，构成ZooKeeper服务的每个服务器都复制其自己的每个组件副本。</div><div class=post-footer><a href=/posts/zookeeper%E5%AD%A6%E4%B9%A0/>阅读全文</a></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/%E5%8F%8D%E5%B0%84/></a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>作者</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=0001-01-01>0001-01-01</time></span></div><div class=content>反射API 反射的用途 反射通常用于检查或者修改程序的运行时行为。这是一个相对高级的功能，只应由对语言基础有很深了解的开发人员使用。反射是一种强大的技术，可以使应用程序执行原本不可能的操作。
反射的缺点 反射功能强大，但不应任意使用。如果可以在不使用反射的情况下执行操作，那么最好避免使用它。通过反射访问代码时，应牢记以下注意事项。
性能开销
由于反射涉及动态解析的类型，因此无法执行某些Java虚拟机优化。因此，反射操作的性能要比非反射操作慢，因此应避免在对性能敏感的应用程序中经常调用的代码段中。
安全限制
反射需要运行时许可，而在安全管理器下运行时可能不存在。对于必须在受限的安全上下文（例如Applet）中运行的代码，这是一个重要的考虑因素。
内部暴露
由于反射允许代码执行在非反射代码中是非法的操作，例如访问私有字段和方法，使用反射可能会导致意外的副作用，这可能会使代码无法正常工作并可能破坏可移植性。
使用说明 检索类对象 所有反射操作的入口点都是java.lang.Class。除了java.lang.reflect.ReflectPermission之外，java.lang.reflect中的所有类都不具有公共构造函数。要进入这些类，必须在Class上调用适当的方法。根据代码是否可以访问对象，类的名称，类型或现有的类，有几种获取类的方法。
Object.getClass()
如果对象的实例可用，则获取其类的最简单方法是调用Object.getClass()。当然，这仅适用于全部继承自Object的引用类型。以下是一些示例。
.class</div><div class=post-footer><a href=/posts/%E5%8F%8D%E5%B0%84/>阅读全文</a></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/></a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>作者</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=0001-01-01>0001-01-01</time></span></div><div class=content>排序算法按时间复杂度可分为3类
O(n^2)
冒泡排序，选择排序，插入排序
O(logn)
快排，归并
O(n)
桶、计数、基数
插入排序和冒泡排序的时间复杂度相同，在实际的软件开发中，为什么我们更倾向于使用插入排序而不是冒泡排序呢？
冒泡排序</div><div class=post-footer><a href=/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/>阅读全文</a></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%80%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/></a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>作者</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=0001-01-01>0001-01-01</time></span></div><div class=content>概述 类加载器负责在运行时将Java类动态加载到JVM。Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最 终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。在Java语言中，类型的加载、连接和初始化过程都是在程序运行期间完成的。
类加载的时机</div><div class=post-footer><a href=/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%80%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/>阅读全文</a></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/></a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>作者</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=0001-01-01>0001-01-01</time></span></div><div class=content>单机容量问题
server端并发线程数上不去
Linux命令
查看Java进程
ps -ef | grep java
查看线程数量
pstree -p pid
pstree -p pid | wc -l
查看机器性能数量
top -H
查看Spring Boot配置
spring-configuration-metadata.json 查看各个节点的配置 默认内嵌Tomcat配置
server.tomcat.accept-count: 等待队列长度，默认100 server.tomcat.max-connections: 最大可被连接数，默认10000 server.tomcat.max-threads: 最大工作线程数，默认200 server.tomcat.min-spare-threads: 最小工作线程数，默认10 默认配置下，连接数超过1000后出现拒绝连接情况
默认配置下，触发的请求超过200+100后拒绝处理
自定义配置（经验配置，4核8G的机器，最大工作线程建议配置800）
server.tomcat.accept-count=1000
server.tomcat.max-threads=800
server.tomcat.min-spare-threads=100
定制化内嵌Tomcat开发
keepAliveTimeOut: 多少毫秒后不响应的断开keepalive maxKeepAliveRequests：多少次请求后keepalive断开失效 响应时间变长，TPS上不去
单Web容器上限
线程数量：4核cpu 8G内存单进程调度线程数800-1000以上后即花费巨大的时间在cpu调度上 等待队列长度：队列做缓冲池用，但也不能无限长，消耗内存，出队入队也耗cpu MySql数据库QPS容量问题
主键查询：千万级别数据 = 1-10毫秒 唯一索引查询：千万级别数据 = 10-100毫秒 非唯一索引查询：千万级别数据=100-1000毫秒 无索引：百万条数据 = 1000毫秒+ 非插入更新删除操作：同查询 插入操作：1w-10w tps （依赖配置优化） 分布式扩展</div><div class=post-footer><a href=/posts/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/>阅读全文</a></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/></a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>作者</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=0001-01-01>0001-01-01</time></span></div><div class=content>二分图最大匹配 二分图：
int[]</div><div class=post-footer><a href=/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/>阅读全文</a></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/></a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>作者</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=0001-01-01>0001-01-01</time></span></div><div class=content>高并发系统设计 为什么学习高并发系统设计 拿电商系统中的下单流程设计技术方案为例。在每秒只有一次调用的系统中，你只需要关注业务逻辑本身就好了：查询库存是否充足，如果充足，就可以到数据库中生成订单，成功后锁定库存，然后进入支付流程。
这个流程非常清晰，实现也简单，但如果要做一次秒杀的活动，配合一些运营的推广，你会发现下单操作的调用量可能达到每秒 10000 次！
10000 次请求同时查询库存，是否会把库存系统拖垮？如果请求全部通过，那么就要同时生成 10000 次订单，数据库能否抗住？如果抗不住，我们要如何做？这些问题都可能出现，并让之前的方案不再适用，此时你就需要设计新的方案。除此之外，同样是缓存的使用，在低并发下你只需要了解基本的使用方式，但在高并发场景下你需要关注缓存命中率，如何应对缓存穿透，如何避免雪崩，如何解决缓存一致性等问题，这就增加了设计方案的复杂度，对设计者能力的要求也会更高。所以，为了避免遇到问题时手忙脚乱，你有必要提前储备足够多的高并发知识，从而具备随时应对可能出现的高并发需求场景的能力。
高并发系统的通用设计方法 高并发代表着大流量，高并发系统设计的魅力就在于我们能够凭借自己的聪明才智设计巧妙的方案，从而抵抗巨大流量的冲击，带给用户更好的使用体验。这些方案好似能操纵流量，让流量更加平稳地被系统中的服务和组件处理。
我们应对高并发大流量时也会采用类似“分洪泄流”的方式，归纳起来共有三种方法：
横向扩展：分而治之是一种常见的高并发系统设计方法，采用分布式部署的方式把流量分流开，让每个服务器都承担一部分并发和流量。 缓存：使用缓存来提高系统的性能，就好比用“拓宽河道”的方式抵抗高并发大流量的冲击。 异步解耦：在某些场景下，未处理完成之前我们可以让请求先返回，在数据准备好之后再通知请求方，这样可以在单位时间内处理更多的请求。 Scale-out 横向扩展 Scale-up与Scale-out
Scale-up类似于追逐摩尔定律不断提升CPU性能，通过购买性能更好的硬件来提升系统处理并发的能力；Scale-out类似于CPU多核心方案，通过将多个低性能的机器组成一个分布式集群来共同抵御高并发流量的冲击。
一般来讲，在我们系统设计初期会考虑使用 Scale-up 的方式，因为这种方案足够简单，所谓能用堆砌硬件解决的问题就用硬件来解决，但是当系统并发超过了单机的极限时，我们就要使用 Scale-out 的方式。
Scale-out 虽然能够突破单机的限制，但也会引入一些复杂问题。比如，如果某个节点出现故障如何保证整体可用性？当多个节点有状态需要同步时如何保证状态信息在不同节点的一致性？如何做到使用方无感知的增加和删除节点？其中每一个问题都涉及很多的知识点，我会在后面的课程中深入地讲解，这里暂时不展开了。
使用缓存提升性能
缓存遍布在系统设计的每个角落，从操作系统到浏览器，从数据库到消息队列，任何略微复杂的服务和组件中你都可以看到缓存的影子。我们使用缓存的主要作用是提升系统的访问性能，在高并发的场景下就可以支撑更多用户的同时访问。
缓存提升性能是因为数据存储在内存中，而数据库持久化存储的是存放在硬盘中的，而磁盘是整个计算机体系中最慢的一环，访问内存比访问硬盘能获的更好的性能提升。
缓存的语义已经丰富了很多，我们可以将任何降低响应时间的中间存储都称为缓存。缓存的思想遍布很多设计领域，比如在操作系统中 CPU 有多级缓存，文件有 Page Cache 缓存。
异步处理
异步也是一种常见的高并发设计方法，我们在很多文章和演讲中都能听到这个名词，与之共同出现的还有它的反义词：同步。比如分布式服务框架 Dubbo 中有同步方法调用和异步方法调用，IO 模型中有同步 IO 和异步 IO。
同步与异步
同步调用代表调用方要阻塞等待被调用方法中的逻辑执行完成。这种方式下，当被调用方法响应时间较长时，会造成调用方长久的阻塞，在高并发下会造成整体系统性能下降甚至发生雪崩。
异步调用恰恰相反，调用方不需要等待方法逻辑执行完成就可以返回执行其他的逻辑，在被调用方法执行完毕后再通过回调、事件通知等方式将结果反馈给调用方。
处理逻辑后移到异步处理程序中，Web 服务的压力小了，资源占用的少了，自然就能接收更多的用户订票请求，系统承受高并发的能力也就提升了。
系统设计的一般思路
一般系统的演进过程应该遵循下面的思路：
最简单的系统设计满足业务需求和流量现状，选择最熟悉的技术体系。
随着流量的增加和业务的变化修正架构中存在问题的点，如单点问题、横向扩展问题、性能无法满足需求的组件。在这个过程中，选择社区成熟的、团队熟悉的组件帮助我们解决问题，在社区没有合适解决方案的前提下才会自己造轮子。
当对架构的小修小补无法满足需求时，考虑重构、重写等大的调整方式以解决现有的问题。
高并发系统的演进应该是循序渐进，以解决系统中存在的问题为目的和驱动力的。
经验讨论
martin fowler好像曾经说过，能使用单体解决的问题，就不要采用分布式。不能为了技术而技术，采用分布式固然可以分流用户请求，提高系统的响应能力，但同样也带来了复杂性。软件开发最终的目的是商业利益。非常赞成老师的观点，罗马城不是一天就建立起来的。架构的工作应该是阶段性，解决阶段性系统的复杂性。如果单体跑的很好，或者通过scale up方式在成本可控的情况能解决就不要想着诗和远方，因为系统内部的进程间调用，肯定比不同物理机的进程之间调用要快。
之前做的创业项目也是遇到盲目优化的问题，系统最核心的撮合结算服务，刚开始只能100次每秒，后来为了优化到百万级，花了大量时间研究各种方案，做了大量的性能测试，耽误了很长时间推向市场，结果最终优化到了不到一万tps，但后面真正上线的结果可能不到也就100tps，所以真正的需求是市场需求，不是一开始就冲着最牛逼的方案搞，线上的需求远比一开始的预想复杂，没足够的资源和动力，绝对不要折腾，不过时刻准备好可能会出现的瓶颈是必要的，免得半夜宕机，慌得一比。</div><div class=post-footer><a href=/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/>阅读全文</a></div></article><ul class=pagination><li class=page-item><span class=page-link><a href=/>1</a></span></li><li class=page-item><span class=page-link><a href=/page/2/>2</a></span></li><li class="page-item active"><span class=page-link><a href=/page/3/>3</a></span></li></ul></div></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.81.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i>LoveIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2021</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank></a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i></a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>