<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>所有文章 - arvin's blog</title><link>https://wzliy.github.io/posts/</link><description>所有文章 | arvin's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 28 Mar 2021 21:39:35 +0800</lastBuildDate><atom:link href="https://wzliy.github.io/posts/" rel="self" type="application/rss+xml"/><item><title>Java引用对象</title><link>https://wzliy.github.io/posts/java%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1/</link><pubDate>Sun, 28 Mar 2021 21:39:35 +0800</pubDate><author>作者</author><guid>https://wzliy.github.io/posts/java%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1/</guid><description><![CDATA[我该如何学会停止担心OutOfMemoryError
 Java堆和对象的生命周期 对于一个从C++到Java的新程序员来说，堆和栈之间的关系可能很难掌握。在C++中，可以通过new的操作在堆上创建对象，或者使用&quot;自动&quot;分配在栈上创建对象。以下是合法的C++程序：它在栈上创建了一个新对象。但是，Java编译器将其拒绝为语法报错。
Integer foo = Integer(1); Java不同于C++，Java将所有的对象都存储于堆中，并要求通过new操作来创建对象。局部变量仍存储在栈上，但是它们持有指向对象的指针，而不是对象本身（当然，更多的是使C++程序员困惑，这些指针被称为&quot;引用&quot;）。思考下面的Java方法，该方法具有一个Integer变量，该变量引用一个从String解析的值：
public static void foo(String bar) { Integer baz = new Integer(bar); } 下图显示了此方法的堆和栈之间的关系。栈被分为一个个的栈帧，其中包含调用树中每个方法的参数和局部变量。这些变量都指向了对象(在本例中为参数bar和局部变量baz), 指向了存活在堆中的对象。
现在更仔细的观察foo()的第一行，分配了一个新的Integer对象。在幕后，JVM首先尝试为此对象找到足够的堆空间(在32位的JVM上大概是12字节)。如果能够分配空间，则调用构造器，该构造器解析已通过的字符串并初始化新分配的对象。最后JVM将指向这个对象的指针保存在变量baz中。
这就是&quot;快乐之路&quot;，有几个不太快乐的地方，其中一个就是，我们关心的是当new操作不能为这个对象找到12个字节的空间时怎么处理。在这种情况下，放弃和抛出OutOfMemoryError之前，它将调用垃圾收集器，试图腾出空间。
垃圾收集器 虽然Java提供了一个new操作来分配堆上的对象，但它没有提供相应的操作来删除它们。当foo()方法返回时，变量baz超出了范围，但它指向的对象仍然存在于堆中。如果这是故事的结尾，那么所有的程序都将很快耗尽内存。然而，Java提供了一个垃圾回收器，以便在不再引用这些对象后进行清理。
当程序尝试创建新对象而在堆中没有足够的空间时，垃圾收集器开始工作。请求线程暂停，收集器通过查看堆空间，试图找到不再积极使用的程序对象，并回收其空间。如果收集器无法释放足够的空间，而JVM无法扩展堆，那么new操作将抛出OutOfMemoryError异常。这通常，这之后是你的应用程序关闭。
标记扫描 Java的一个持久神话围绕着垃圾收集器展开。许多人认为，JVM保存了每个对象的引用次数，而收集器只查看引用次数为零的对象。实际上，JVM使用了一种&quot;标记扫描(Mark-sweep)&ldquo;的技术。标记扫描垃圾收集背后的理念很简单：程序无法到达的每个对象都是垃圾，可以进行回收。
标记扫描收集有以下阶段：
第1阶段：标记
垃圾收集器从&quot;root&quot;引用开始，并遍历对象图，标记它到达的所有对象。
第2阶段：扫描
任何在第一阶段未标记的对象都是无法到达的，因此是垃圾对象。如果垃圾对象定义了终结器(fanalizer)，则将其添加到终结器队列(finalization queue)中。如果没有，它的空间可用于重新分配(确切的含义取决于特定的GC实现，并且有许多实现)。
第3阶段：紧凑(可选)
有些垃圾收集器有第三步：压实。在此步骤中，GC将对象移动到合并收集的垃圾留下的自由空间。这个可以防止堆空间碎片化，从而导致大的连续分配失败。
例如，hotspot JVM 在新生代中使用压缩收集器，但在其老年代中使用非压缩收集器(至少在1.6和1.7版本)。
root引用 那么，&ldquo;root&quot;是什么？在一个简单的Java应用程序中，它们是方法参数和局部变量(存储在栈上)，当前执行表达式的操作（也存储在栈上）和静态类成员变量。
在使用自己的类加载器的程序中，含义变得模糊不清：只有被系统类加载器加载的类包含root引用(JVM启动时使用的加载器)。应用程序创建的任何类加载器本身都会受到垃圾收集器的约束，一旦没有更多的引用指向他们。这就是允许应用服务器进行热部署的原因：它们为每个已部署的应用程序创建一个单独的类加载器，并在应用程序未部署或重新部署时放弃类加载器的引用。
了解root引用很重要，因为它定义了什么是&quot;强&quot;引用: 如果你能够遵循从root到特定对象的一系列引用，则该对象被&quot;强烈&quot;引用。它不会被垃圾回收。
因此，回到foo()方法，bar参数和baz局部变量只有在方法执行时才具有强引用，一旦方法完成，它们都将超出范围，并且所引用的对象也可以进行收集。另外，foo()方法可能会返回一个它创建的Integer引用，这意味着该对象仍将被调用foo()的方法强烈引用。
现在考虑以下事项：
LinkedList foo = new LinkedList(); foo.add(new Integer(123)); 变量foo是一个指向LinkList对象的root引用。linked list里面有零个或多个列表元素，每个元素都指向其后续内容。当我们调用add()方法时，我们添加了一个新的list元素，并且该list元素指向一个值为123的实例。这是一个强的引用链，这意味着该Integer对象不符合收集条件。然而，一旦foo 超出了范围，LinkedList和它其中的所有内容都可以进行收集&ndash;当然，前提是没有其他的强引用指向它。
你可能想知道，如果你有一个循环引用，会发生什么情况：对象A包含对对象B的引用，对象B包含对A的引用。答案是，标记扫描收集器不会被愚弄：如果A和B都无法通过一系列的强引用到达，那么他们都能够被收集。
Finalizers C++允许对象定义一个清理方法：当对象脱离了作用域或被明确删除时，这个清理方法被调用用来清理其使用的资源。对于大多数对象，这意味着显式释放通过new或者malloc分配对象的任何内存。在Java中，垃圾收集器为你清理内存，因此无需明确的清理方法来处理此操作。
但是内存并不是唯一的需要清理的资源。想想FileOutputStream: 当你创建这个对象的实例的时候，它会从操作系统分配文件句柄。如果你在关闭流之前让流的所有引用都退出作用域，该文件句柄会发生什么情况呢？答案是，流有一个Finalizer 方法：在垃圾收集器回收对象之前调用的一个方法。在这个FileOutputStream的例子中，finalizer方法关闭流，将文件句柄释放回操作系统，并冲洗任何缓冲区，确保所有数据都正确地写入磁盘。
任何对象都可以有finalizers: 你所需要做的就是声明finalize() 方法：
protected void finalize() throws Throwable { // cleanup your object here } 虽然finalizers似乎是一种清理自己的简单方法，但是，它们确实存在一些严重的局限性。首先，你不应该依赖他们来处理任何重要的事情，因为对象的finalizers可能永远不会被调用&ndash;应用程序可能在对象有资格进行垃圾回收之前退出。finalizers还有一些其他的更微妙的问题，稍后我们会在幻象引用的时候来讨论它。]]></description></item><item><title>引用类型</title><link>https://wzliy.github.io/posts/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</link><pubDate>Sun, 28 Mar 2021 21:39:35 +0800</pubDate><author>作者</author><guid>https://wzliy.github.io/posts/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</guid><description>Java的引用类型分为四种：强引用，弱引用，软引用，幻象引用。</description></item><item><title/><link>https://wzliy.github.io/posts/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>作者</author><guid>https://wzliy.github.io/posts/about/</guid><description>testdfs</description></item></channel></rss>