<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>Java引用对象 - arvin's blog</title><meta name=Description content><meta property="og:title" content="Java引用对象"><meta property="og:description" content="我该如何学会停止担心OutOfMemoryError
 Java堆和对象的生命周期 对于一个从C++到Java的新程序员来说，堆和栈之间的关系可能很难掌握。在C++中，可以通过new的操作在堆上创建对象，或者使用&#34;自动&#34;分配在栈上创建对象。以下是合法的C++程序：它在栈上创建了一个新对象。但是，Java编译器将其拒绝为语法报错。
Integer foo = Integer(1); Java不同于C++，Java将所有的对象都存储于堆中，并要求通过new操作来创建对象。局部变量仍存储在栈上，但是它们持有指向对象的指针，而不是对象本身（当然，更多的是使C++程序员困惑，这些指针被称为&#34;引用&#34;）。思考下面的Java方法，该方法具有一个Integer变量，该变量引用一个从String解析的值：
public static void foo(String bar) { Integer baz = new Integer(bar); } 下图显示了此方法的堆和栈之间的关系。栈被分为一个个的栈帧，其中包含调用树中每个方法的参数和局部变量。这些变量都指向了对象(在本例中为参数bar和局部变量baz), 指向了存活在堆中的对象。
现在更仔细的观察foo()的第一行，分配了一个新的Integer对象。在幕后，JVM首先尝试为此对象找到足够的堆空间(在32位的JVM上大概是12字节)。如果能够分配空间，则调用构造器，该构造器解析已通过的字符串并初始化新分配的对象。最后JVM将指向这个对象的指针保存在变量baz中。
这就是&#34;快乐之路&#34;，有几个不太快乐的地方，其中一个就是，我们关心的是当new操作不能为这个对象找到12个字节的空间时怎么处理。在这种情况下，放弃和抛出OutOfMemoryError之前，它将调用垃圾收集器，试图腾出空间。
垃圾收集器 虽然Java提供了一个new操作来分配堆上的对象，但它没有提供相应的操作来删除它们。当foo()方法返回时，变量baz超出了范围，但它指向的对象仍然存在于堆中。如果这是故事的结尾，那么所有的程序都将很快耗尽内存。然而，Java提供了一个垃圾回收器，以便在不再引用这些对象后进行清理。
当程序尝试创建新对象而在堆中没有足够的空间时，垃圾收集器开始工作。请求线程暂停，收集器通过查看堆空间，试图找到不再积极使用的程序对象，并回收其空间。如果收集器无法释放足够的空间，而JVM无法扩展堆，那么new操作将抛出OutOfMemoryError异常。这通常，这之后是你的应用程序关闭。
标记扫描 Java的一个持久神话围绕着垃圾收集器展开。许多人认为，JVM保存了每个对象的引用次数，而收集器只查看引用次数为零的对象。实际上，JVM使用了一种&#34;标记扫描(Mark-sweep)&ldquo;的技术。标记扫描垃圾收集背后的理念很简单：程序无法到达的每个对象都是垃圾，可以进行回收。
标记扫描收集有以下阶段：
第1阶段：标记
垃圾收集器从&#34;root&#34;引用开始，并遍历对象图，标记它到达的所有对象。
第2阶段：扫描
任何在第一阶段未标记的对象都是无法到达的，因此是垃圾对象。如果垃圾对象定义了终结器(fanalizer)，则将其添加到终结器队列(finalization queue)中。如果没有，它的空间可用于重新分配(确切的含义取决于特定的GC实现，并且有许多实现)。
第3阶段：紧凑(可选)
有些垃圾收集器有第三步：压实。在此步骤中，GC将对象移动到合并收集的垃圾留下的自由空间。这个可以防止堆空间碎片化，从而导致大的连续分配失败。
例如，hotspot JVM 在新生代中使用压缩收集器，但在其老年代中使用非压缩收集器(至少在1.6和1.7版本)。
root引用 那么，&ldquo;root&#34;是什么？在一个简单的Java应用程序中，它们是方法参数和局部变量(存储在栈上)，当前执行表达式的操作（也存储在栈上）和静态类成员变量。
在使用自己的类加载器的程序中，含义变得模糊不清：只有被系统类加载器加载的类包含root引用(JVM启动时使用的加载器)。应用程序创建的任何类加载器本身都会受到垃圾收集器的约束，一旦没有更多的引用指向他们。这就是允许应用服务器进行热部署的原因：它们为每个已部署的应用程序创建一个单独的类加载器，并在应用程序未部署或重新部署时放弃类加载器的引用。
了解root引用很重要，因为它定义了什么是&#34;强&#34;引用: 如果你能够遵循从root到特定对象的一系列引用，则该对象被&#34;强烈&#34;引用。它不会被垃圾回收。
因此，回到foo()方法，bar参数和baz局部变量只有在方法执行时才具有强引用，一旦方法完成，它们都将超出范围，并且所引用的对象也可以进行收集。另外，foo()方法可能会返回一个它创建的Integer引用，这意味着该对象仍将被调用foo()的方法强烈引用。
现在考虑以下事项：
LinkedList foo = new LinkedList(); foo.add(new Integer(123)); 变量foo是一个指向LinkList对象的root引用。linked list里面有零个或多个列表元素，每个元素都指向其后续内容。当我们调用add()方法时，我们添加了一个新的list元素，并且该list元素指向一个值为123的实例。这是一个强的引用链，这意味着该Integer对象不符合收集条件。然而，一旦foo 超出了范围，LinkedList和它其中的所有内容都可以进行收集&ndash;当然，前提是没有其他的强引用指向它。
你可能想知道，如果你有一个循环引用，会发生什么情况：对象A包含对对象B的引用，对象B包含对A的引用。答案是，标记扫描收集器不会被愚弄：如果A和B都无法通过一系列的强引用到达，那么他们都能够被收集。
Finalizers C++允许对象定义一个清理方法：当对象脱离了作用域或被明确删除时，这个清理方法被调用用来清理其使用的资源。对于大多数对象，这意味着显式释放通过new或者malloc分配对象的任何内存。在Java中，垃圾收集器为你清理内存，因此无需明确的清理方法来处理此操作。
但是内存并不是唯一的需要清理的资源。想想FileOutputStream: 当你创建这个对象的实例的时候，它会从操作系统分配文件句柄。如果你在关闭流之前让流的所有引用都退出作用域，该文件句柄会发生什么情况呢？答案是，流有一个Finalizer 方法：在垃圾收集器回收对象之前调用的一个方法。在这个FileOutputStream的例子中，finalizer方法关闭流，将文件句柄释放回操作系统，并冲洗任何缓冲区，确保所有数据都正确地写入磁盘。
任何对象都可以有finalizers: 你所需要做的就是声明finalize() 方法：
protected void finalize() throws Throwable { // cleanup your object here } 虽然finalizers似乎是一种清理自己的简单方法，但是，它们确实存在一些严重的局限性。首先，你不应该依赖他们来处理任何重要的事情，因为对象的finalizers可能永远不会被调用&ndash;应用程序可能在对象有资格进行垃圾回收之前退出。finalizers还有一些其他的更微妙的问题，稍后我们会在幻象引用的时候来讨论它。"><meta property="og:type" content="article"><meta property="og:url" content="https://wzliy.github.io/posts/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-03-28T21:39:35+08:00"><meta property="article:modified_time" content="2021-03-28T21:39:35+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java引用对象"><meta name=twitter:description content="我该如何学会停止担心OutOfMemoryError
 Java堆和对象的生命周期 对于一个从C++到Java的新程序员来说，堆和栈之间的关系可能很难掌握。在C++中，可以通过new的操作在堆上创建对象，或者使用&#34;自动&#34;分配在栈上创建对象。以下是合法的C++程序：它在栈上创建了一个新对象。但是，Java编译器将其拒绝为语法报错。
Integer foo = Integer(1); Java不同于C++，Java将所有的对象都存储于堆中，并要求通过new操作来创建对象。局部变量仍存储在栈上，但是它们持有指向对象的指针，而不是对象本身（当然，更多的是使C++程序员困惑，这些指针被称为&#34;引用&#34;）。思考下面的Java方法，该方法具有一个Integer变量，该变量引用一个从String解析的值：
public static void foo(String bar) { Integer baz = new Integer(bar); } 下图显示了此方法的堆和栈之间的关系。栈被分为一个个的栈帧，其中包含调用树中每个方法的参数和局部变量。这些变量都指向了对象(在本例中为参数bar和局部变量baz), 指向了存活在堆中的对象。
现在更仔细的观察foo()的第一行，分配了一个新的Integer对象。在幕后，JVM首先尝试为此对象找到足够的堆空间(在32位的JVM上大概是12字节)。如果能够分配空间，则调用构造器，该构造器解析已通过的字符串并初始化新分配的对象。最后JVM将指向这个对象的指针保存在变量baz中。
这就是&#34;快乐之路&#34;，有几个不太快乐的地方，其中一个就是，我们关心的是当new操作不能为这个对象找到12个字节的空间时怎么处理。在这种情况下，放弃和抛出OutOfMemoryError之前，它将调用垃圾收集器，试图腾出空间。
垃圾收集器 虽然Java提供了一个new操作来分配堆上的对象，但它没有提供相应的操作来删除它们。当foo()方法返回时，变量baz超出了范围，但它指向的对象仍然存在于堆中。如果这是故事的结尾，那么所有的程序都将很快耗尽内存。然而，Java提供了一个垃圾回收器，以便在不再引用这些对象后进行清理。
当程序尝试创建新对象而在堆中没有足够的空间时，垃圾收集器开始工作。请求线程暂停，收集器通过查看堆空间，试图找到不再积极使用的程序对象，并回收其空间。如果收集器无法释放足够的空间，而JVM无法扩展堆，那么new操作将抛出OutOfMemoryError异常。这通常，这之后是你的应用程序关闭。
标记扫描 Java的一个持久神话围绕着垃圾收集器展开。许多人认为，JVM保存了每个对象的引用次数，而收集器只查看引用次数为零的对象。实际上，JVM使用了一种&#34;标记扫描(Mark-sweep)&ldquo;的技术。标记扫描垃圾收集背后的理念很简单：程序无法到达的每个对象都是垃圾，可以进行回收。
标记扫描收集有以下阶段：
第1阶段：标记
垃圾收集器从&#34;root&#34;引用开始，并遍历对象图，标记它到达的所有对象。
第2阶段：扫描
任何在第一阶段未标记的对象都是无法到达的，因此是垃圾对象。如果垃圾对象定义了终结器(fanalizer)，则将其添加到终结器队列(finalization queue)中。如果没有，它的空间可用于重新分配(确切的含义取决于特定的GC实现，并且有许多实现)。
第3阶段：紧凑(可选)
有些垃圾收集器有第三步：压实。在此步骤中，GC将对象移动到合并收集的垃圾留下的自由空间。这个可以防止堆空间碎片化，从而导致大的连续分配失败。
例如，hotspot JVM 在新生代中使用压缩收集器，但在其老年代中使用非压缩收集器(至少在1.6和1.7版本)。
root引用 那么，&ldquo;root&#34;是什么？在一个简单的Java应用程序中，它们是方法参数和局部变量(存储在栈上)，当前执行表达式的操作（也存储在栈上）和静态类成员变量。
在使用自己的类加载器的程序中，含义变得模糊不清：只有被系统类加载器加载的类包含root引用(JVM启动时使用的加载器)。应用程序创建的任何类加载器本身都会受到垃圾收集器的约束，一旦没有更多的引用指向他们。这就是允许应用服务器进行热部署的原因：它们为每个已部署的应用程序创建一个单独的类加载器，并在应用程序未部署或重新部署时放弃类加载器的引用。
了解root引用很重要，因为它定义了什么是&#34;强&#34;引用: 如果你能够遵循从root到特定对象的一系列引用，则该对象被&#34;强烈&#34;引用。它不会被垃圾回收。
因此，回到foo()方法，bar参数和baz局部变量只有在方法执行时才具有强引用，一旦方法完成，它们都将超出范围，并且所引用的对象也可以进行收集。另外，foo()方法可能会返回一个它创建的Integer引用，这意味着该对象仍将被调用foo()的方法强烈引用。
现在考虑以下事项：
LinkedList foo = new LinkedList(); foo.add(new Integer(123)); 变量foo是一个指向LinkList对象的root引用。linked list里面有零个或多个列表元素，每个元素都指向其后续内容。当我们调用add()方法时，我们添加了一个新的list元素，并且该list元素指向一个值为123的实例。这是一个强的引用链，这意味着该Integer对象不符合收集条件。然而，一旦foo 超出了范围，LinkedList和它其中的所有内容都可以进行收集&ndash;当然，前提是没有其他的强引用指向它。
你可能想知道，如果你有一个循环引用，会发生什么情况：对象A包含对对象B的引用，对象B包含对A的引用。答案是，标记扫描收集器不会被愚弄：如果A和B都无法通过一系列的强引用到达，那么他们都能够被收集。
Finalizers C++允许对象定义一个清理方法：当对象脱离了作用域或被明确删除时，这个清理方法被调用用来清理其使用的资源。对于大多数对象，这意味着显式释放通过new或者malloc分配对象的任何内存。在Java中，垃圾收集器为你清理内存，因此无需明确的清理方法来处理此操作。
但是内存并不是唯一的需要清理的资源。想想FileOutputStream: 当你创建这个对象的实例的时候，它会从操作系统分配文件句柄。如果你在关闭流之前让流的所有引用都退出作用域，该文件句柄会发生什么情况呢？答案是，流有一个Finalizer 方法：在垃圾收集器回收对象之前调用的一个方法。在这个FileOutputStream的例子中，finalizer方法关闭流，将文件句柄释放回操作系统，并冲洗任何缓冲区，确保所有数据都正确地写入磁盘。
任何对象都可以有finalizers: 你所需要做的就是声明finalize() 方法：
protected void finalize() throws Throwable { // cleanup your object here } 虽然finalizers似乎是一种清理自己的简单方法，但是，它们确实存在一些严重的局限性。首先，你不应该依赖他们来处理任何重要的事情，因为对象的finalizers可能永远不会被调用&ndash;应用程序可能在对象有资格进行垃圾回收之前退出。finalizers还有一些其他的更微妙的问题，稍后我们会在幻象引用的时候来讨论它。"><meta name=application-name content="arvin's blog"><meta name=apple-mobile-web-app-title content="arvin's blog"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://wzliy.github.io/posts/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/><link rel=prev href=https://wzliy.github.io/posts/about/><link rel=next href=https://wzliy.github.io/posts/java%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Java引用对象","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/wzliy.github.io\/posts\/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B\/"},"genre":"posts","wordcount":153,"url":"https:\/\/wzliy.github.io\/posts\/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B\/","datePublished":"2021-03-28T21:39:35+08:00","dateModified":"2021-03-28T21:39:35+08:00","publisher":{"@type":"Organization","name":"arvin"},"author":{"@type":"Person","name":"arvin"},"description":""}</script></head><body header-desktop header-mobile><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':''==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:''==='dark')&&document.body.setAttribute('theme','dark')</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="arvin's blog">arvin's blog</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="arvin's blog">arvin's blog</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">Java引用对象</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>arvin</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2021-03-28>2021-03-28</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 153 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 1 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><ul><li><a href=#java堆和对象的生命周期>Java堆和对象的生命周期</a></li><li><a href=#垃圾收集器>垃圾收集器</a></li><li><a href=#输入引用对象>输入引用对象</a></li></ul></li></ul></nav></div></div><div class=content id=content><blockquote><p>我该如何学会停止担心OutOfMemoryError</p></blockquote><h3 id=java堆和对象的生命周期>Java堆和对象的生命周期</h3><p>对于一个从C++到Java的新程序员来说，堆和栈之间的关系可能很难掌握。在C++中，可以通过new的操作在堆上创建对象，或者使用"自动"分配在栈上创建对象。以下是合法的C++程序：它在栈上创建了一个新对象。但是，Java编译器将其拒绝为语法报错。</p><div class=highlight><pre class=chroma><code class=language-C++ data-lang=C++><span class=n>Integer</span> <span class=n>foo</span> <span class=o>=</span> <span class=n>Integer</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</code></pre></div><p>Java不同于C++，Java将所有的对象都存储于堆中，并要求通过<code>new</code>操作来创建对象。局部变量仍存储在栈上，但是它们持有指向对象的指针，而不是对象本身（当然，更多的是使C++程序员困惑，这些指针被称为"引用"）。思考下面的Java方法，该方法具有一个Integer变量，该变量引用一个从String解析的值：</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>foo</span><span class=o>(</span><span class=n>String</span> <span class=n>bar</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>Integer</span> <span class=n>baz</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Integer</span><span class=o>(</span><span class=n>bar</span><span class=o>);</span>
<span class=o>}</span>
</code></pre></div><p>下图显示了此方法的堆和栈之间的关系。栈被分为一个个的栈帧，其中包含调用树中每个方法的参数和局部变量。这些变量都指向了对象(在本例中为参数<code>bar</code>和局部变量<code>baz</code>), 指向了存活在堆中的对象。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/jvm/stack_and_heap.gif data-srcset="/jvm/stack_and_heap.gif, /jvm/stack_and_heap.gif 1.5x, /jvm/stack_and_heap.gif 2x" data-sizes=auto alt=/jvm/stack_and_heap.gif title=stack_and_heap></p><p>现在更仔细的观察<code>foo()</code>的第一行，分配了一个新的Integer对象。在幕后，JVM首先尝试为此对象找到足够的堆空间(在32位的JVM上大概是12字节)。如果能够分配空间，则调用构造器，该构造器解析已通过的字符串并初始化新分配的对象。最后JVM将指向这个对象的指针保存在变量<code>baz</code>中。</p><p>这就是"快乐之路"，有几个不太快乐的地方，其中一个就是，我们关心的是当<code>new</code>操作不能为这个对象找到12个字节的空间时怎么处理。在这种情况下，放弃和抛出OutOfMemoryError之前，它将调用垃圾收集器，试图腾出空间。</p><h3 id=垃圾收集器>垃圾收集器</h3><p>虽然Java提供了一个<code>new</code>操作来分配堆上的对象，但它没有提供相应的操作来删除它们。当<code>foo()</code>方法返回时，变量<code>baz</code>超出了范围，但它指向的对象仍然存在于堆中。如果这是故事的结尾，那么所有的程序都将很快耗尽内存。然而，Java提供了一个垃圾回收器，以便在不再引用这些对象后进行清理。</p><p>当程序尝试创建新对象而在堆中没有足够的空间时，垃圾收集器开始工作。请求线程暂停，收集器通过查看堆空间，试图找到不再积极使用的程序对象，并回收其空间。如果收集器无法释放足够的空间，而JVM无法扩展堆，那么<code>new</code>操作将抛出OutOfMemoryError异常。这通常，这之后是你的应用程序关闭。</p><h4 id=标记扫描>标记扫描</h4><p>Java的一个持久神话围绕着垃圾收集器展开。许多人认为，JVM保存了每个对象的引用次数，而收集器只查看引用次数为零的对象。实际上，JVM使用了一种"标记扫描(Mark-sweep)&ldquo;的技术。标记扫描垃圾收集背后的理念很简单：程序无法到达的每个对象都是垃圾，可以进行回收。</p><p>标记扫描收集有以下阶段：</p><p><strong>第1阶段：标记</strong></p><p>垃圾收集器从"root"引用开始，并遍历对象图，标记它到达的所有对象。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/jvm/gc_mark.gif data-srcset="/jvm/gc_mark.gif, /jvm/gc_mark.gif 1.5x, /jvm/gc_mark.gif 2x" data-sizes=auto alt=/jvm/gc_mark.gif title=gc_mark></p><p><strong>第2阶段：扫描</strong></p><p>任何在第一阶段未标记的对象都是无法到达的，因此是垃圾对象。如果垃圾对象定义了终结器(fanalizer)，则将其添加到终结器队列(finalization queue)中。如果没有，它的空间可用于重新分配(确切的含义取决于特定的GC实现，并且有许多实现)。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/jvm/gc_sweep.gif data-srcset="/jvm/gc_sweep.gif, /jvm/gc_sweep.gif 1.5x, /jvm/gc_sweep.gif 2x" data-sizes=auto alt=/jvm/gc_sweep.gif title=gc_sweep></p><p><strong>第3阶段：紧凑(可选)</strong></p><p>有些垃圾收集器有第三步：压实。在此步骤中，GC将对象移动到合并收集的垃圾留下的自由空间。这个可以防止堆空间碎片化，从而导致大的连续分配失败。</p><p>例如，hotspot JVM 在新生代中使用压缩收集器，但在其老年代中使用非压缩收集器(至少在1.6和1.7版本)。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/jvm/gc_compact.gif data-srcset="/jvm/gc_compact.gif, /jvm/gc_compact.gif 1.5x, /jvm/gc_compact.gif 2x" data-sizes=auto alt=/jvm/gc_compact.gif title=gc_compact></p><h4 id=root引用>root引用</h4><p>那么，&ldquo;root"是什么？在一个简单的Java应用程序中，它们是方法参数和局部变量(存储在栈上)，当前执行表达式的操作（也存储在栈上）和静态类成员变量。</p><p>在使用自己的类加载器的程序中，含义变得模糊不清：只有被系统类加载器加载的类包含root引用(JVM启动时使用的加载器)。应用程序创建的任何类加载器本身都会受到垃圾收集器的约束，一旦没有更多的引用指向他们。这就是允许应用服务器进行热部署的原因：它们为每个已部署的应用程序创建一个单独的类加载器，并在应用程序未部署或重新部署时放弃类加载器的引用。</p><p>了解root引用很重要，因为它定义了什么是"强"引用: 如果你能够遵循从root到特定对象的一系列引用，则该对象被"强烈"引用。它不会被垃圾回收。</p><p>因此，回到<code>foo()</code>方法，<code>bar</code>参数和<code>baz</code>局部变量只有在方法执行时才具有强引用，一旦方法完成，它们都将超出范围，并且所引用的对象也可以进行收集。另外，<code>foo()</code>方法可能会返回一个它创建的<code>Integer</code>引用，这意味着该对象仍将被调用<code>foo()</code>的方法强烈引用。</p><p>现在考虑以下事项：</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>LinkedList</span> <span class=n>foo</span> <span class=o>=</span> <span class=k>new</span> <span class=n>LinkedList</span><span class=o>();</span>
<span class=n>foo</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=k>new</span> <span class=n>Integer</span><span class=o>(</span><span class=n>123</span><span class=o>));</span>
</code></pre></div><p>变量foo是一个指向LinkList对象的root引用。linked list里面有零个或多个列表元素，每个元素都指向其后续内容。当我们调用add()方法时，我们添加了一个新的list元素，并且该list元素指向一个值为123的实例。这是一个强的引用链，这意味着该Integer对象不符合收集条件。然而，一旦foo 超出了范围，LinkedList和它其中的所有内容都可以进行收集&ndash;当然，前提是没有其他的强引用指向它。</p><p>你可能想知道，如果你有一个循环引用，会发生什么情况：对象A包含对对象B的引用，对象B包含对A的引用。答案是，标记扫描收集器不会被愚弄：如果A和B都无法通过一系列的强引用到达，那么他们都能够被收集。</p><h4 id=finalizers>Finalizers</h4><p>C++允许对象定义一个清理方法：当对象脱离了作用域或被明确删除时，这个清理方法被调用用来清理其使用的资源。对于大多数对象，这意味着显式释放通过new或者malloc分配对象的任何内存。在Java中，垃圾收集器为你清理内存，因此无需明确的清理方法来处理此操作。</p><p>但是内存并不是唯一的需要清理的资源。想想FileOutputStream: 当你创建这个对象的实例的时候，它会从操作系统分配文件句柄。如果你在关闭流之前让流的所有引用都退出作用域，该文件句柄会发生什么情况呢？答案是，流有一个Finalizer 方法：在垃圾收集器回收对象之前调用的一个方法。在这个FileOutputStream的例子中，finalizer方法关闭流，将文件句柄释放回操作系统，并冲洗任何缓冲区，确保所有数据都正确地写入磁盘。</p><p>任何对象都可以有finalizers: 你所需要做的就是声明finalize() 方法：</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=kd>protected</span> <span class=kt>void</span> <span class=nf>finalize</span><span class=o>()</span> <span class=kd>throws</span> <span class=n>Throwable</span> <span class=o>{</span>
    <span class=c1>// cleanup your object here
</span><span class=c1></span><span class=o>}</span>
</code></pre></div><p>虽然finalizers似乎是一种清理自己的简单方法，但是，它们确实存在一些严重的局限性。首先，你不应该依赖他们来处理任何重要的事情，因为对象的finalizers可能永远不会被调用&ndash;应用程序可能在对象有资格进行垃圾回收之前退出。finalizers还有一些其他的更微妙的问题，稍后我们会在幻象引用的时候来讨论它。</p><h4 id=对象生命周期>对象生命周期</h4><p>综上所示，一个对象的生命周期可以通过下图简单的概括：它被创建，它被使用，它变得有资格被收集，并最终它被收集。阴影区域表示对象"强烈可到达"的时间，与引用对象提供的可达性相比，这个术语变得非常重要。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/jvm/object_life_cycle.gif data-srcset="/jvm/object_life_cycle.gif, /jvm/object_life_cycle.gif 1.5x, /jvm/object_life_cycle.gif 2x" data-sizes=auto alt=/jvm/object_life_cycle.gif title=object_life_cycle></p><h3 id=输入引用对象>输入引用对象</h3><p>JDK 1.2引入了该<a href=https://docs.oracle.com/javase/8/docs/api/java/lang/ref/package-summary.html target=_blank rel="noopener noreffer"><code>java.lang.ref</code></a> 包，并在对象生命周期中引入了三个新阶段：可软到达，可弱到达和幻像可到达。这些状态仅适用于可回收的对象&ndash;换句话说，那些没有强引用的，有关的对象必须是<em>引用</em> 一个引用对象：</p><ul><li><p><em><strong>软引用</strong></em></p><p>该对象的引用是软引用<code>SoftReference</code>，并且没有对它的强引用。垃圾收集器将尝试尽可能长时间地保留对象，但是将在抛出<code>OutOfMemoryError</code>之前对其进行收集。</p></li><li><p><em><strong>弱引用</strong></em></p><p>对象的引用是弱引用<code>WeakReference</code>，并且没有对它的强引用或软引用。垃圾收集器可以随时自由收集对象，而无需尝试保留它。在实践中，对象将在主要收集期间收集，但可以在次要收集中保留下来。</p></li><li><p><em><strong>幻象引用</strong></em></p><p>该对象的引用是幻象引用<code>PhantomReference</code>，并且已经选择了该对象进行收集，并且其终结器（如果有）已经运行。在这种情况下，“可到达”一词确实是用词不当，因为你无法访问实际对象。</p></li></ul><p>你可能会猜到，在对象生命周期图中添加三个新的可选状态会造成混乱。尽管文档指出从强可及性到软可及性，弱可及性和幻像可及性，再到回收的逻辑进展，但实际进展取决于程序创建的引用对象。如果创建一个<code>WeakReference</code>但不创建<code>SoftReference</code>，则一个对象会从强可及性直接变为弱可及性，最后发展为最终收集。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=D:%5cblog%5chugo%5cwzliy.github.io.source%5cstatic%5cjvm%5cobject_life_cycle_with_refobj.gif data-srcset="D:%5cblog%5chugo%5cwzliy.github.io.source%5cstatic%5cjvm%5cobject_life_cycle_with_refobj.gif, D:%5cblog%5chugo%5cwzliy.github.io.source%5cstatic%5cjvm%5cobject_life_cycle_with_refobj.gif 1.5x, D:%5cblog%5chugo%5cwzliy.github.io.source%5cstatic%5cjvm%5cobject_life_cycle_with_refobj.gif 2x" data-sizes=auto alt=D:\blog\hugo\wzliy.github.io.source\static\jvm\object_life_cycle_with_refobj.gif title=D:\blog\hugo\wzliy.github.io.source\static\jvm\object_life_cycle_with_refobj.gif></p><p>同样重要的是要了解并非所有对象都附加在引用对象上&ndash;实际上，很少有对象应该附加到引用对象上。引用对象是一个间接层：您遍历该引用才能到达引用对象，并且显然，你不希望整个代码中都使用该间接层。实际上，大多数程序将使用引用对象来访问程序创建的相对较少的对象。</p><h4 id=引用与被引用>引用与被引用</h4><p>引用对象是程序代码和被引用对象（称为*Referent）*之间的间接层。每个参照物都围绕其参照物构造，并且参照物不能更改。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=D:%5cblog%5chugo%5cwzliy.github.io.source%5cstatic%5cjvm%5cnormal_refobj_relations.gif data-srcset="D:%5cblog%5chugo%5cwzliy.github.io.source%5cstatic%5cjvm%5cnormal_refobj_relations.gif, D:%5cblog%5chugo%5cwzliy.github.io.source%5cstatic%5cjvm%5cnormal_refobj_relations.gif 1.5x, D:%5cblog%5chugo%5cwzliy.github.io.source%5cstatic%5cjvm%5cnormal_refobj_relations.gif 2x" data-sizes=auto alt=D:\blog\hugo\wzliy.github.io.source\static\jvm\normal_refobj_relations.gif title=D:\blog\hugo\wzliy.github.io.source\static\jvm\normal_refobj_relations.gif></p><p>引用对象提供了<code>get()</code>方法来检索对其引用对象的强引用。垃圾收集器可以随时回收引用对象；一旦发生这种情况，<code>get()</code>将返回 <code>null</code>。为了正确使用引用，您需要如下代码：</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>SoftReference</span><span class=o>&lt;</span><span class=n>List</span><span class=o>&lt;</span><span class=n>Foo</span><span class=o>&gt;&gt;</span> <span class=n>ref</span> <span class=o>=</span> <span class=k>new</span> <span class=n>SoftReference</span><span class=o>&lt;</span><span class=n>List</span><span class=o>&lt;</span><span class=n>Foo</span><span class=o>&gt;&gt;(</span><span class=k>new</span> <span class=n>LinkedList</span><span class=o>&lt;</span><span class=n>Foo</span><span class=o>&gt;());</span>

<span class=c1>// somewhere else in your code, you create a Foo that you want to add to the list
</span><span class=c1></span><span class=n>List</span><span class=o>&lt;</span><span class=n>Foo</span><span class=o>&gt;</span> <span class=n>list</span> <span class=o>=</span> <span class=n>ref</span><span class=o>.</span><span class=na>get</span><span class=o>();</span>
<span class=k>if</span> <span class=o>(</span><span class=n>list</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>){</span>
    <span class=n>list</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>foo</span><span class=o>);</span>
<span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
    <span class=c1>// list is gone; do whatever is appropriate
</span><span class=c1></span><span class=o>}</span>
</code></pre></div><p>用文字表示就是：</p><ol><li><em>你必须始终检查该引用对象是否为<code>null</code></em>
垃圾收集器可以随时清除该引用，并且如果你乐于使用该引用，则迟早会得到一个NullPointerException。</li><li><em>你必须持有一个强引用指向它</em>
再次，垃圾收集器可以在任何时间清除引用，即使是在一个表达式的中间。如果不是创建 <code>list</code>变量而是直接调用 <code>ref.get().add(foo)</code>，则该引用可能在检查null和实际使用之间被清除。<em>永远记住，垃圾收集器在其自己的线程中运行，并且不在乎你的代码在做什么</em>。</li><li><em>您必须拥有对引用对象的强引用。</em>
如果创建引用对象，但允许其超出范围，则引用对象本身将被垃圾回收。似乎很明显，但是却很容易忘记，尤其是当您使用引用队列（<em>qv</em>）来跟踪引用时。</li></ol><p>还请记住，仅当不再有对引用对象的强引用时，软引用，弱引用和幻像引用才起作用。它们的存在是为了让你能够抓住那些通常会成为垃圾收集器回收的对象。这似乎是一件奇怪的事情-如果你不再拥有强引用，为什么还要关心该对象？原因取决于特定的引用类型。</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2021-03-28</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/about/ class=prev rel=prev title><i class="fas fa-angle-left fa-fw"></i></a><a href=/posts/java%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1/ class=next rel=next title=Java引用对象>Java引用对象<i class="fas fa-angle-right fa-fw"></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.81.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i>LoveIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2021</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank></a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i></a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>