<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>Java引用对象 - arvin's blog</title><meta name=Description content><meta property="og:title" content="Java引用对象"><meta property="og:description" content="我该如何学会停止担心OutOfMemoryError
 Java堆和对象的生命周期 对于一个从C++到Java的新程序员来说，堆和栈之间的关系可能很难掌握。在C++中，对象可以通过new的操作在堆上创建，也可以使用自动分配在栈上创建。以下是C++的程序：它在栈上创建了一个新对象。但是，Java编译器
会报错。
Integer foo = Integer(1); Java不同于c++，所有的对象都存储于堆中，它需要通过new操作来创建对象。本地变量仍存储在栈上，但存储的是指向对象的指针，而不是对象本身（当然，为了与C++程序区分，这些指针被称为引用）。思考下面的Java方法，有一个Integer的变量引用了一个从String转换过来的值：
public static void foo(String bar) { Integer baz = new Integer(bar); } 下图显示了此方法的堆和栈之间的关系。栈被分为一个个的栈帧，栈帧中包含了每个方法的参数和局部变量。这些变量都指向了对象&ndash;在本例中，参数bar和局部变量baz指向了存活在堆中的对象。
现在更仔细的观察foo()的第一行，分配了一个新的Integer对象。在幕后，JVM首先尝试为此对象找到足够的堆空间(在32位的JVM上大概是12字节)。如果能够分配空间，则调用构造器，该构造器解析已通过的字符串并初始化新分配的对象。最后JVM将指向这个对象的指针保存在变量baz中。
这就是&#34;快乐之路&#34;，有几个不太快乐的地方，其中一个就是，我们关心的是当new操作不能为这个对象找到12个字节的空间时怎么处理。在这种情况下，放弃和抛出OutOfMemoryError之前，它将调用垃圾收集器，试图腾出空间。
垃圾收集器 虽然Java提供了一个new操作来分配堆上的对象，但它没有提供相应的操作来删除它们。当foo()方法返回时，这个baz变量超出了范围，但它指向的对象仍然存在于堆上。如果这是故事的结尾，那么所有的程序都会很快耗尽内存。然而，Java提供了一个垃圾收集器，以便在不再引用这些对象后进行清理。
当程序尝试创建新对象而在堆中没有足够的空间时，垃圾收集器开始工作。请求线程暂停，收集器通过查看堆空间，试图找到不再积极使用的程序对象，并回收其空间。如果收集器无法释放足够的空间，而JVM无法扩展堆，那么new操作将抛出OutOfMemoryError异常。这通常伴随着你的程序关闭。
标记扫描 Java的一个持久的神话围绕着垃圾收集器。许多人认为，JVM保存了每个对象的引用次数，而收集器只查看引用次数为零的对象。实际上，JVM使用了一种称为&#34;标记扫描(Mark-sweep)&ldquo;的技术。标记扫描垃圾收集背后的理念很简单：程序无法到达的每个对象都是垃圾，并且有资格收集。
标记扫描收集有以下阶段：
第1阶段：标记
垃圾收集器从&#34;root&#34;引用开始，穿过标有其到达的所有对象的对象图。
第2阶段：扫描
任何在第一阶段没有标记的对象都是无法到达的，因此是垃圾对象。如果垃圾对象定义了fanalizer,则将其添加到finalization queue中。如果没有，则将其空间进行重新分配(具体含义取决于具体的GC实施，并且有许多实现)。
第3阶段：压缩(可选)
有些垃圾收集器有第三步：压缩。在此步骤中，GC移动对象用来汇集垃圾回收后留下的自由空间。这个可以防止堆空间变得支离破碎导致的分配大量连续空间失败。
例如，hotspot JVM 在新生代中使用压缩收集器，但在其老年代中使用非压缩收集器(至少在1.6和1.7版本)。
root引用 那么，&ldquo;root&#34;是什么？在一个简单的Java应用程序中，它们是方法参数和本地变量(存储在栈上)，当前执行表达式的操作（也存储在栈上）和静态类成员变量。
在使用自己的类加载器的程序中，含义变得模糊不清：只有被系统的类加载器加载的类包含root引用(JVM启动时使用的加载器)。应用程序创建的任何类加载器本身都会受到垃圾收集器的约束，一旦没有更多的引用指向他们。这就是允许应用服务器进行热部署的原因：它们为每个已部署的应用程序创建一个单独的类加载器，并在应用程序未部署或重新部署时放弃类加载器的引用。
了解root引用很重要，因为它定义了什么是&#34;强&#34;引用: 如果你能够遵循从root到特定对象的引用链，则该对象被&#34;强烈&#34;引用。它不会被垃圾回收。
因此，回到foo()方法，bar参数和baz局部变量只有在方法执行时才具有强引用，一旦方法完成，它们都脱离了范围，他们引用的对象都有资格被垃圾收集。或者，foo()方法可以返回一个它创建的Integer引用，这意味着该对象仍将被调用foo()的方法强烈引用。
现在考虑以下事项：
LinkedList foo = new LinkedList(); foo.add(new Integer(123)); 变量foo是一个指向LinkList对象的root引用。linked list里面有零个或多个列表元素，每个元素都指向其后续内容。当我们调用add()方法时，我们添加了一个新的列表元素，该列表元素指向具有值123的实例。这是一个强的引用链，这意味着垃圾收集器不会收集它们。然而，一旦foo 超出了范围，LinkedList和它里面的所有东西都能被回收了&ndash;当然，只要没有其他的强引用指向它。
你可能想知道，如果你有一个循环引用，会发生什么情况：对象A包含一个对象B的引用，其中包含返回A的引用。答案是，标记扫描收集器不会被愚弄：如果A和B都无法通过一系列的强引用到达，那么他们都能够被收集。
Finalizers C++允许对象定义一个清理方法：当对象脱离了作用域或被明确删除时，这个清理方法被调用用来清理其使用的资源。对于大多数对象，这意味着明确的释放通过new或者malloc分配对象的任何内存。在Java中，垃圾收集器为你清理内存，因此无需明确的清理方法来处理此操作。
但是内存并不是唯一的需要清理的资源。想想FileOutputStream: 当你创建这个对象的实例的时候，它会从操作系统分配文件句柄。如果你在关闭流之前让流的所有引用都退出作用域，该文件句柄会发生什么情况呢？答案是，流有一个Finalizer 方法：在垃圾收集器回收对象之前调用的一个方法。在这个FileOutputStream的例子中，finalizer方法关闭流，将文件句柄释放回操作系统，并冲洗任何缓冲区，确保所有数据都正确地写入磁盘。
任何对象都可以有finalizers: 你所需要做的就是声明finalize() 方法：
protected void finalize() throws Throwable { // cleanup your object here } 虽然finalizers似乎是一种简单的处理方法在清理对象之后，但是，他们还是有一些严重的限制。首先，你不应该依赖他们来获取任何重要的东西，因为对象的finalizers可能永远不会被调用&ndash;应用程序可能会在垃圾收集器开始清理对象的时候退出。还有一些其他的，finalizers的更微妙的问题，稍后我们会在幻象引用的时候来讨论它。"><meta property="og:type" content="article"><meta property="og:url" content="https://wzliy.github.io/posts/java%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-03-28T21:39:35+08:00"><meta property="article:modified_time" content="2021-03-28T21:39:35+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java引用对象"><meta name=twitter:description content="我该如何学会停止担心OutOfMemoryError
 Java堆和对象的生命周期 对于一个从C++到Java的新程序员来说，堆和栈之间的关系可能很难掌握。在C++中，对象可以通过new的操作在堆上创建，也可以使用自动分配在栈上创建。以下是C++的程序：它在栈上创建了一个新对象。但是，Java编译器
会报错。
Integer foo = Integer(1); Java不同于c++，所有的对象都存储于堆中，它需要通过new操作来创建对象。本地变量仍存储在栈上，但存储的是指向对象的指针，而不是对象本身（当然，为了与C++程序区分，这些指针被称为引用）。思考下面的Java方法，有一个Integer的变量引用了一个从String转换过来的值：
public static void foo(String bar) { Integer baz = new Integer(bar); } 下图显示了此方法的堆和栈之间的关系。栈被分为一个个的栈帧，栈帧中包含了每个方法的参数和局部变量。这些变量都指向了对象&ndash;在本例中，参数bar和局部变量baz指向了存活在堆中的对象。
现在更仔细的观察foo()的第一行，分配了一个新的Integer对象。在幕后，JVM首先尝试为此对象找到足够的堆空间(在32位的JVM上大概是12字节)。如果能够分配空间，则调用构造器，该构造器解析已通过的字符串并初始化新分配的对象。最后JVM将指向这个对象的指针保存在变量baz中。
这就是&#34;快乐之路&#34;，有几个不太快乐的地方，其中一个就是，我们关心的是当new操作不能为这个对象找到12个字节的空间时怎么处理。在这种情况下，放弃和抛出OutOfMemoryError之前，它将调用垃圾收集器，试图腾出空间。
垃圾收集器 虽然Java提供了一个new操作来分配堆上的对象，但它没有提供相应的操作来删除它们。当foo()方法返回时，这个baz变量超出了范围，但它指向的对象仍然存在于堆上。如果这是故事的结尾，那么所有的程序都会很快耗尽内存。然而，Java提供了一个垃圾收集器，以便在不再引用这些对象后进行清理。
当程序尝试创建新对象而在堆中没有足够的空间时，垃圾收集器开始工作。请求线程暂停，收集器通过查看堆空间，试图找到不再积极使用的程序对象，并回收其空间。如果收集器无法释放足够的空间，而JVM无法扩展堆，那么new操作将抛出OutOfMemoryError异常。这通常伴随着你的程序关闭。
标记扫描 Java的一个持久的神话围绕着垃圾收集器。许多人认为，JVM保存了每个对象的引用次数，而收集器只查看引用次数为零的对象。实际上，JVM使用了一种称为&#34;标记扫描(Mark-sweep)&ldquo;的技术。标记扫描垃圾收集背后的理念很简单：程序无法到达的每个对象都是垃圾，并且有资格收集。
标记扫描收集有以下阶段：
第1阶段：标记
垃圾收集器从&#34;root&#34;引用开始，穿过标有其到达的所有对象的对象图。
第2阶段：扫描
任何在第一阶段没有标记的对象都是无法到达的，因此是垃圾对象。如果垃圾对象定义了fanalizer,则将其添加到finalization queue中。如果没有，则将其空间进行重新分配(具体含义取决于具体的GC实施，并且有许多实现)。
第3阶段：压缩(可选)
有些垃圾收集器有第三步：压缩。在此步骤中，GC移动对象用来汇集垃圾回收后留下的自由空间。这个可以防止堆空间变得支离破碎导致的分配大量连续空间失败。
例如，hotspot JVM 在新生代中使用压缩收集器，但在其老年代中使用非压缩收集器(至少在1.6和1.7版本)。
root引用 那么，&ldquo;root&#34;是什么？在一个简单的Java应用程序中，它们是方法参数和本地变量(存储在栈上)，当前执行表达式的操作（也存储在栈上）和静态类成员变量。
在使用自己的类加载器的程序中，含义变得模糊不清：只有被系统的类加载器加载的类包含root引用(JVM启动时使用的加载器)。应用程序创建的任何类加载器本身都会受到垃圾收集器的约束，一旦没有更多的引用指向他们。这就是允许应用服务器进行热部署的原因：它们为每个已部署的应用程序创建一个单独的类加载器，并在应用程序未部署或重新部署时放弃类加载器的引用。
了解root引用很重要，因为它定义了什么是&#34;强&#34;引用: 如果你能够遵循从root到特定对象的引用链，则该对象被&#34;强烈&#34;引用。它不会被垃圾回收。
因此，回到foo()方法，bar参数和baz局部变量只有在方法执行时才具有强引用，一旦方法完成，它们都脱离了范围，他们引用的对象都有资格被垃圾收集。或者，foo()方法可以返回一个它创建的Integer引用，这意味着该对象仍将被调用foo()的方法强烈引用。
现在考虑以下事项：
LinkedList foo = new LinkedList(); foo.add(new Integer(123)); 变量foo是一个指向LinkList对象的root引用。linked list里面有零个或多个列表元素，每个元素都指向其后续内容。当我们调用add()方法时，我们添加了一个新的列表元素，该列表元素指向具有值123的实例。这是一个强的引用链，这意味着垃圾收集器不会收集它们。然而，一旦foo 超出了范围，LinkedList和它里面的所有东西都能被回收了&ndash;当然，只要没有其他的强引用指向它。
你可能想知道，如果你有一个循环引用，会发生什么情况：对象A包含一个对象B的引用，其中包含返回A的引用。答案是，标记扫描收集器不会被愚弄：如果A和B都无法通过一系列的强引用到达，那么他们都能够被收集。
Finalizers C++允许对象定义一个清理方法：当对象脱离了作用域或被明确删除时，这个清理方法被调用用来清理其使用的资源。对于大多数对象，这意味着明确的释放通过new或者malloc分配对象的任何内存。在Java中，垃圾收集器为你清理内存，因此无需明确的清理方法来处理此操作。
但是内存并不是唯一的需要清理的资源。想想FileOutputStream: 当你创建这个对象的实例的时候，它会从操作系统分配文件句柄。如果你在关闭流之前让流的所有引用都退出作用域，该文件句柄会发生什么情况呢？答案是，流有一个Finalizer 方法：在垃圾收集器回收对象之前调用的一个方法。在这个FileOutputStream的例子中，finalizer方法关闭流，将文件句柄释放回操作系统，并冲洗任何缓冲区，确保所有数据都正确地写入磁盘。
任何对象都可以有finalizers: 你所需要做的就是声明finalize() 方法：
protected void finalize() throws Throwable { // cleanup your object here } 虽然finalizers似乎是一种简单的处理方法在清理对象之后，但是，他们还是有一些严重的限制。首先，你不应该依赖他们来获取任何重要的东西，因为对象的finalizers可能永远不会被调用&ndash;应用程序可能会在垃圾收集器开始清理对象的时候退出。还有一些其他的，finalizers的更微妙的问题，稍后我们会在幻象引用的时候来讨论它。"><meta name=application-name content="arvin's blog"><meta name=apple-mobile-web-app-title content="arvin's blog"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://wzliy.github.io/posts/java%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1/><link rel=prev href=https://wzliy.github.io/posts/about/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Java引用对象","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/wzliy.github.io\/posts\/java%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1\/"},"genre":"posts","wordcount":82,"url":"https:\/\/wzliy.github.io\/posts\/java%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1\/","datePublished":"2021-03-28T21:39:35+08:00","dateModified":"2021-03-28T21:39:35+08:00","publisher":{"@type":"Organization","name":"arvin"},"author":{"@type":"Person","name":"arvin"},"description":""}</script></head><body header-desktop header-mobile><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':''==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:''==='dark')&&document.body.setAttribute('theme','dark')</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="arvin's blog">arvin's blog</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="arvin's blog">arvin's blog</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">Java引用对象</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>arvin</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2021-03-28>2021-03-28</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 82 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 1 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><ul><li><a href=#java堆和对象的生命周期>Java堆和对象的生命周期</a></li><li><a href=#垃圾收集器>垃圾收集器</a></li><li><a href=#引用对象>引用对象</a></li></ul></li></ul></nav></div></div><div class=content id=content><blockquote><p>我该如何学会停止担心OutOfMemoryError</p></blockquote><h3 id=java堆和对象的生命周期>Java堆和对象的生命周期</h3><p>对于一个从C++到Java的新程序员来说，堆和栈之间的关系可能很难掌握。在C++中，对象可以通过new的操作在堆上创建，也可以使用自动分配在栈上创建。以下是C++的程序：它在栈上创建了一个新对象。但是，Java编译器</p><p>会报错。</p><div class=highlight><pre class=chroma><code class=language-C++ data-lang=C++><span class=n>Integer</span> <span class=n>foo</span> <span class=o>=</span> <span class=n>Integer</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</code></pre></div><p>Java不同于c++，所有的对象都存储于堆中，它需要通过<code>new</code>操作来创建对象。本地变量仍存储在栈上，但存储的是指向对象的指针，而不是对象本身（当然，为了与C++程序区分，这些指针被称为引用）。思考下面的Java方法，有一个Integer的变量引用了一个从String转换过来的值：</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>foo</span><span class=o>(</span><span class=n>String</span> <span class=n>bar</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>Integer</span> <span class=n>baz</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Integer</span><span class=o>(</span><span class=n>bar</span><span class=o>);</span>
<span class=o>}</span>
</code></pre></div><p>下图显示了此方法的堆和栈之间的关系。栈被分为一个个的栈帧，栈帧中包含了每个方法的参数和局部变量。这些变量都指向了对象&ndash;在本例中，参数<code>bar</code>和局部变量<code>baz</code>指向了存活在堆中的对象。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/jvm/stack_and_heap.gif data-srcset="/jvm/stack_and_heap.gif, /jvm/stack_and_heap.gif 1.5x, /jvm/stack_and_heap.gif 2x" data-sizes=auto alt=/jvm/stack_and_heap.gif title=stack_and_heap></p><p>现在更仔细的观察<code>foo()</code>的第一行，分配了一个新的Integer对象。在幕后，JVM首先尝试为此对象找到足够的堆空间(在32位的JVM上大概是12字节)。如果能够分配空间，则调用构造器，该构造器解析已通过的字符串并初始化新分配的对象。最后JVM将指向这个对象的指针保存在变量<code>baz</code>中。</p><p>这就是"快乐之路"，有几个不太快乐的地方，其中一个就是，我们关心的是当<code>new</code>操作不能为这个对象找到12个字节的空间时怎么处理。在这种情况下，放弃和抛出OutOfMemoryError之前，它将调用垃圾收集器，试图腾出空间。</p><h3 id=垃圾收集器>垃圾收集器</h3><p>虽然Java提供了一个<code>new</code>操作来分配堆上的对象，但它没有提供相应的操作来删除它们。当<code>foo()</code>方法返回时，这个<code>baz</code>变量超出了范围，但它指向的对象仍然存在于堆上。如果这是故事的结尾，那么所有的程序都会很快耗尽内存。然而，Java提供了一个垃圾收集器，以便在不再引用这些对象后进行清理。</p><p>当程序尝试创建新对象而在堆中没有足够的空间时，垃圾收集器开始工作。请求线程暂停，收集器通过查看堆空间，试图找到不再积极使用的程序对象，并回收其空间。如果收集器无法释放足够的空间，而JVM无法扩展堆，那么<code>new</code>操作将抛出OutOfMemoryError异常。这通常伴随着你的程序关闭。</p><h4 id=标记扫描>标记扫描</h4><p>Java的一个持久的神话围绕着垃圾收集器。许多人认为，JVM保存了每个对象的引用次数，而收集器只查看引用次数为零的对象。实际上，JVM使用了一种称为"标记扫描(Mark-sweep)&ldquo;的技术。标记扫描垃圾收集背后的理念很简单：程序无法到达的每个对象都是垃圾，并且有资格收集。</p><p>标记扫描收集有以下阶段：</p><p><strong>第1阶段：标记</strong></p><p>垃圾收集器从"root"引用开始，穿过标有其到达的所有对象的对象图。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/jvm/gc_mark.gif data-srcset="/jvm/gc_mark.gif, /jvm/gc_mark.gif 1.5x, /jvm/gc_mark.gif 2x" data-sizes=auto alt=/jvm/gc_mark.gif title=gc_mark></p><p><strong>第2阶段：扫描</strong></p><p>任何在第一阶段没有标记的对象都是无法到达的，因此是垃圾对象。如果垃圾对象定义了fanalizer,则将其添加到finalization queue中。如果没有，则将其空间进行重新分配(具体含义取决于具体的GC实施，并且有许多实现)。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/jvm/gc_sweep.gif data-srcset="/jvm/gc_sweep.gif, /jvm/gc_sweep.gif 1.5x, /jvm/gc_sweep.gif 2x" data-sizes=auto alt=/jvm/gc_sweep.gif title=gc_sweep></p><p><strong>第3阶段：压缩(可选)</strong></p><p>有些垃圾收集器有第三步：压缩。在此步骤中，GC移动对象用来汇集垃圾回收后留下的自由空间。这个可以防止堆空间变得支离破碎导致的分配大量连续空间失败。</p><p>例如，hotspot JVM 在新生代中使用压缩收集器，但在其老年代中使用非压缩收集器(至少在1.6和1.7版本)。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/jvm/gc_compact.gif data-srcset="/jvm/gc_compact.gif, /jvm/gc_compact.gif 1.5x, /jvm/gc_compact.gif 2x" data-sizes=auto alt=/jvm/gc_compact.gif title=gc_compact></p><h4 id=root引用>root引用</h4><p>那么，&ldquo;root"是什么？在一个简单的Java应用程序中，它们是方法参数和本地变量(存储在栈上)，当前执行表达式的操作（也存储在栈上）和静态类成员变量。</p><p>在使用自己的类加载器的程序中，含义变得模糊不清：只有被系统的类加载器加载的类包含root引用(JVM启动时使用的加载器)。应用程序创建的任何类加载器本身都会受到垃圾收集器的约束，一旦没有更多的引用指向他们。这就是允许应用服务器进行热部署的原因：它们为每个已部署的应用程序创建一个单独的类加载器，并在应用程序未部署或重新部署时放弃类加载器的引用。</p><p>了解root引用很重要，因为它定义了什么是"强"引用: 如果你能够遵循从root到特定对象的引用链，则该对象被"强烈"引用。它不会被垃圾回收。</p><p>因此，回到<code>foo()</code>方法，<code>bar</code>参数和<code>baz</code>局部变量只有在方法执行时才具有强引用，一旦方法完成，它们都脱离了范围，他们引用的对象都有资格被垃圾收集。或者，<code>foo()</code>方法可以返回一个它创建的<code>Integer</code>引用，这意味着该对象仍将被调用<code>foo()</code>的方法强烈引用。</p><p>现在考虑以下事项：</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>LinkedList</span> <span class=n>foo</span> <span class=o>=</span> <span class=k>new</span> <span class=n>LinkedList</span><span class=o>();</span>
<span class=n>foo</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=k>new</span> <span class=n>Integer</span><span class=o>(</span><span class=n>123</span><span class=o>));</span>
</code></pre></div><p>变量foo是一个指向LinkList对象的root引用。linked list里面有零个或多个列表元素，每个元素都指向其后续内容。当我们调用add()方法时，我们添加了一个新的列表元素，该列表元素指向具有值123的实例。这是一个强的引用链，这意味着垃圾收集器不会收集它们。然而，一旦foo 超出了范围，LinkedList和它里面的所有东西都能被回收了&ndash;当然，只要没有其他的强引用指向它。</p><p>你可能想知道，如果你有一个循环引用，会发生什么情况：对象A包含一个对象B的引用，其中包含返回A的引用。答案是，标记扫描收集器不会被愚弄：如果A和B都无法通过一系列的强引用到达，那么他们都能够被收集。</p><h4 id=finalizers>Finalizers</h4><p>C++允许对象定义一个清理方法：当对象脱离了作用域或被明确删除时，这个清理方法被调用用来清理其使用的资源。对于大多数对象，这意味着明确的释放通过new或者malloc分配对象的任何内存。在Java中，垃圾收集器为你清理内存，因此无需明确的清理方法来处理此操作。</p><p>但是内存并不是唯一的需要清理的资源。想想FileOutputStream: 当你创建这个对象的实例的时候，它会从操作系统分配文件句柄。如果你在关闭流之前让流的所有引用都退出作用域，该文件句柄会发生什么情况呢？答案是，流有一个Finalizer 方法：在垃圾收集器回收对象之前调用的一个方法。在这个FileOutputStream的例子中，finalizer方法关闭流，将文件句柄释放回操作系统，并冲洗任何缓冲区，确保所有数据都正确地写入磁盘。</p><p>任何对象都可以有finalizers: 你所需要做的就是声明finalize() 方法：</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=kd>protected</span> <span class=kt>void</span> <span class=nf>finalize</span><span class=o>()</span> <span class=kd>throws</span> <span class=n>Throwable</span> <span class=o>{</span>
    <span class=c1>// cleanup your object here
</span><span class=c1></span><span class=o>}</span>
</code></pre></div><p>虽然finalizers似乎是一种简单的处理方法在清理对象之后，但是，他们还是有一些严重的限制。首先，你不应该依赖他们来获取任何重要的东西，因为对象的finalizers可能永远不会被调用&ndash;应用程序可能会在垃圾收集器开始清理对象的时候退出。还有一些其他的，finalizers的更微妙的问题，稍后我们会在幻象引用的时候来讨论它。</p><h4 id=对象生命周期>对象生命周期</h4><p>综上所示，一个对象的生命周期可以通过下图简单的概括：它被创建，它被使用，它变得有资格被收集，并最终它被收集。阴影区域表示对象"强烈可到达"的时间，与引用对象提供的可达性相比，这个术语变得非常重要。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/jvm/object_life_cycle.gif data-srcset="/jvm/object_life_cycle.gif, /jvm/object_life_cycle.gif 1.5x, /jvm/object_life_cycle.gif 2x" data-sizes=auto alt=/jvm/object_life_cycle.gif title=object_life_cycle></p><h3 id=引用对象>引用对象</h3></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2021-03-28</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/about/ class=prev rel=prev title><i class="fas fa-angle-left fa-fw"></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.81.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i>LoveIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2021</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank></a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i></a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>