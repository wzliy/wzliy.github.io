<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>- arvin's blog</title><meta name=Description content><meta property="og:title" content><meta property="og:description" content="Zookeeper zookeeper是针对分布式应用程序的高性能协调服务。它在一个简单的接口中提供了通用的服务-比如naming，configuration management，synchronization，group service，因此，你不必从头开始编写它们。你可以现成使用它来实现共识，组管理，领导者选举和状态协议。你也可以根据自己的特定需求在此基础上构建。
Zookeeper的典型应用场景：
 配置管理 DNS服务 组成员管理(group membership) 各种分布式锁  Zookeeper适用于存储和协同相关的关键数据，不适合用于大数据量存储。
概述 Zookeeper：分布式应用程序的分布式协调服务 Zookeeper是一个分布式的，开源的协调服务，用于分布式应用程序，它提供了一组简单的原语，分布式应用程序可以基于这些原语来实现用于同步，配置维护以及组和命名空间的更高级别的服务。它被设计成易于编程的，并使用了按照文件系统熟悉的目录树结构样式设置的数据模型。它以Java运行，并且具有Java和C的绑定。
众所周知，协调服务很难做到。它们特别容易出现诸如竞态条件和死锁之类的错误。Zookeeper背后的动机是减轻分布式应用程序从头开始实施协调服务的责任。
设计目标 Zookeeper是一个开源的分布式协调服务系统。Zookeeper的设计目标是将那些复杂且容易出错的分布式协同服务封装起来，抽象出一个高效可靠的原语集，并以一系列简单的接口提供给用户使用。
ZooKeeper 是简单的。Zookeeper允许分布式进程通过共享的分层名称空间相互协调，该命名空间的组织方式类似于标准文件系统。命名空间由数据寄存器组成（Zookeeper中叫znode）组成，它们类似于文件和目录。与设计用于存储的典型文件系统不同，Zookeeper数据保留在内存中，这意味着Zookeeper可以实现高吞吐量和低延迟数。
Zookeeper的实现重视高性能、高可用、严格有序访问。Zookeeper的性能方面意味着它可以在大型的分布式系统中使用。可靠性方面使它不会成为单点故障。严格的有序意味着可以在客户端上实现复杂的同步原语。
Zookeeper是可复制的。像它协调的分布式进程一样，Zookeeper本身也可以在称为集群的一组主机上进行复制。
组成Zookeeper服务的服务器都必须知道彼此。它们维护内存中的状态图像，以及持久化存储中的事务日志和快照。只要大多数服务器可用，Zookeeper服务将可用。
客户端连接到单个Zookeeper服务器。客户端维护一个TCP连接，通过该连接发送请求，获取响应，获取监视事件并发送心跳。如果与服务器的TCP连接断开，则客户端将连接到其他服务器。
Zookeeper是有序的。Zookeeper用一个反映所有Zookeeper事务顺序的数字标记每个更新。后续操作可以使用该命令来实现更高级别的抽象，例如同步原语。
Zookeeper是快速的。在&#34;读取为主&#34;的工作负载中，它特别快。Zookeeper应用程序可在数千台计算机上运行，并且在读取比写入更常见的情况下以10：1的比率运行效果最佳。
Zookeeper数据模型 Zookeeper提供的命名空间与标准文件系统的名称空间非常相似。名称是由斜杆（/）分隔的一系列路径元素。Zookeeper命名空间中的每个节点都由路径标识。
Zookeeper的数据模型是层次模型。层次模型常见于文件系统。层次模型和key-value模型是两种主流的数据模型。Zookeeper使用文件系统模型主要基于以下两点考虑：
 文件系统的树形结构便于表达数据之间的层次关系； 文件系统的树形结构便于为不同的应用分配独立的命名空间(namespace)；  Zookeeper的层次模型称为data tree。Data tree的每个节点叫做znode.不同于文件系统，每个节点都可以保存数据，每个节点都有一个版本，版本从0开始计数。
节点和瞬时节点 与标准文件系统不同，Zookeeper命名空间中的每个节点都可以具有与其关联的数据以及子节点。就像拥有一个文件系统一样，该文件系统也允许文件成为目录。（Zookeeper旨在存储协调数据：状态信息、配置、位置信息等，因此存储在每个节点上的数据通常很小，在千字节范围内。）我们使用术语znode来明确表示我们正在谈论Zookeeper数据节点。
Znodes维护一个统计信息结构，其中包括用于数据更改，ACL更改和时间戳的版本号，以允许进行缓存验证和协调更新。znode的数据每次更改时，版本号都会增加。例如，每当客户端检索数据时，它也接收数据的版本。
读取和写入存储在名称空间中每个znode上的数据都是原子操作。读取将获取与znode关联的所有数据字节，而写入将替换所有数据。每个节点都有一个访问控制列表（ACL），用于限制谁可以执行操作。
ZooKeeper还具有瞬时节点的概念。只要创建znode的会话处于活动状态，这些znode就存在。会话结束时，将删除znode。
条件更新和监视器 ZooKeeper支持 监视 的概念。客户端可以在znode上设置监视器。znode更改时，将触发并删除监视。当触发监视后，客户端会收到一个数据包，说明znode已更改。如果客户端与其中一个ZooKeeper服务器之间的连接断开，则客户端将收到本地通知。
3.6.0中的新增功能：客户端还可以在znode上设置永久性的递归监视，这些监视在触发时不会删除，并且会以递归方式触发已注册znode以及所有子znode的更改。
特性 ZooKeeper非常快速且非常简单。但是，由于其目标是作为构建更复杂的服务（例如同步）的基础，因此它提供了一组保证。它们是：
 顺序一致性&ndash;来自客户端的更新将按照发送的顺序应用。 原子性&ndash;全部更新成功或失败。没有部分结果。 单个系统映像&ndash;无论客户端连接到哪个服务器，客户端都将看到该服务的相同视图。即，即使客户端故障转移到具有相同会话的其他服务器，客户端也永远不会看到系统的较旧视图。 可靠性&ndash;应用更新后，此更新将一直持续到客户端覆盖更新为止。 及时性&ndash;保证系统的客户视图在特定时间内是最新的。  简单的API ZooKeeper的设计目标之一是提供一个非常简单的编程界面。因此，它仅支持以下操作：
 create：在树中的某个位置创建一个节点 delete：删除一个节点 exists：判断某个位置是否存在节点 get data：从节点读取数据 set data：将数据写入节点 get children：检索节点的子级列表 sync：等待数据传播  执行 ZooKeeper组件显示ZooKeeper服务的高级组件。除请求处理器外，构成ZooKeeper服务的每个服务器都复制其自己的每个组件副本。"><meta property="og:type" content="article"><meta property="og:url" content="https://wzliy.github.io/posts/zookeeper%E5%AD%A6%E4%B9%A0/"><meta property="article:section" content="posts"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="Zookeeper zookeeper是针对分布式应用程序的高性能协调服务。它在一个简单的接口中提供了通用的服务-比如naming，configuration management，synchronization，group service，因此，你不必从头开始编写它们。你可以现成使用它来实现共识，组管理，领导者选举和状态协议。你也可以根据自己的特定需求在此基础上构建。
Zookeeper的典型应用场景：
 配置管理 DNS服务 组成员管理(group membership) 各种分布式锁  Zookeeper适用于存储和协同相关的关键数据，不适合用于大数据量存储。
概述 Zookeeper：分布式应用程序的分布式协调服务 Zookeeper是一个分布式的，开源的协调服务，用于分布式应用程序，它提供了一组简单的原语，分布式应用程序可以基于这些原语来实现用于同步，配置维护以及组和命名空间的更高级别的服务。它被设计成易于编程的，并使用了按照文件系统熟悉的目录树结构样式设置的数据模型。它以Java运行，并且具有Java和C的绑定。
众所周知，协调服务很难做到。它们特别容易出现诸如竞态条件和死锁之类的错误。Zookeeper背后的动机是减轻分布式应用程序从头开始实施协调服务的责任。
设计目标 Zookeeper是一个开源的分布式协调服务系统。Zookeeper的设计目标是将那些复杂且容易出错的分布式协同服务封装起来，抽象出一个高效可靠的原语集，并以一系列简单的接口提供给用户使用。
ZooKeeper 是简单的。Zookeeper允许分布式进程通过共享的分层名称空间相互协调，该命名空间的组织方式类似于标准文件系统。命名空间由数据寄存器组成（Zookeeper中叫znode）组成，它们类似于文件和目录。与设计用于存储的典型文件系统不同，Zookeeper数据保留在内存中，这意味着Zookeeper可以实现高吞吐量和低延迟数。
Zookeeper的实现重视高性能、高可用、严格有序访问。Zookeeper的性能方面意味着它可以在大型的分布式系统中使用。可靠性方面使它不会成为单点故障。严格的有序意味着可以在客户端上实现复杂的同步原语。
Zookeeper是可复制的。像它协调的分布式进程一样，Zookeeper本身也可以在称为集群的一组主机上进行复制。
组成Zookeeper服务的服务器都必须知道彼此。它们维护内存中的状态图像，以及持久化存储中的事务日志和快照。只要大多数服务器可用，Zookeeper服务将可用。
客户端连接到单个Zookeeper服务器。客户端维护一个TCP连接，通过该连接发送请求，获取响应，获取监视事件并发送心跳。如果与服务器的TCP连接断开，则客户端将连接到其他服务器。
Zookeeper是有序的。Zookeeper用一个反映所有Zookeeper事务顺序的数字标记每个更新。后续操作可以使用该命令来实现更高级别的抽象，例如同步原语。
Zookeeper是快速的。在&#34;读取为主&#34;的工作负载中，它特别快。Zookeeper应用程序可在数千台计算机上运行，并且在读取比写入更常见的情况下以10：1的比率运行效果最佳。
Zookeeper数据模型 Zookeeper提供的命名空间与标准文件系统的名称空间非常相似。名称是由斜杆（/）分隔的一系列路径元素。Zookeeper命名空间中的每个节点都由路径标识。
Zookeeper的数据模型是层次模型。层次模型常见于文件系统。层次模型和key-value模型是两种主流的数据模型。Zookeeper使用文件系统模型主要基于以下两点考虑：
 文件系统的树形结构便于表达数据之间的层次关系； 文件系统的树形结构便于为不同的应用分配独立的命名空间(namespace)；  Zookeeper的层次模型称为data tree。Data tree的每个节点叫做znode.不同于文件系统，每个节点都可以保存数据，每个节点都有一个版本，版本从0开始计数。
节点和瞬时节点 与标准文件系统不同，Zookeeper命名空间中的每个节点都可以具有与其关联的数据以及子节点。就像拥有一个文件系统一样，该文件系统也允许文件成为目录。（Zookeeper旨在存储协调数据：状态信息、配置、位置信息等，因此存储在每个节点上的数据通常很小，在千字节范围内。）我们使用术语znode来明确表示我们正在谈论Zookeeper数据节点。
Znodes维护一个统计信息结构，其中包括用于数据更改，ACL更改和时间戳的版本号，以允许进行缓存验证和协调更新。znode的数据每次更改时，版本号都会增加。例如，每当客户端检索数据时，它也接收数据的版本。
读取和写入存储在名称空间中每个znode上的数据都是原子操作。读取将获取与znode关联的所有数据字节，而写入将替换所有数据。每个节点都有一个访问控制列表（ACL），用于限制谁可以执行操作。
ZooKeeper还具有瞬时节点的概念。只要创建znode的会话处于活动状态，这些znode就存在。会话结束时，将删除znode。
条件更新和监视器 ZooKeeper支持 监视 的概念。客户端可以在znode上设置监视器。znode更改时，将触发并删除监视。当触发监视后，客户端会收到一个数据包，说明znode已更改。如果客户端与其中一个ZooKeeper服务器之间的连接断开，则客户端将收到本地通知。
3.6.0中的新增功能：客户端还可以在znode上设置永久性的递归监视，这些监视在触发时不会删除，并且会以递归方式触发已注册znode以及所有子znode的更改。
特性 ZooKeeper非常快速且非常简单。但是，由于其目标是作为构建更复杂的服务（例如同步）的基础，因此它提供了一组保证。它们是：
 顺序一致性&ndash;来自客户端的更新将按照发送的顺序应用。 原子性&ndash;全部更新成功或失败。没有部分结果。 单个系统映像&ndash;无论客户端连接到哪个服务器，客户端都将看到该服务的相同视图。即，即使客户端故障转移到具有相同会话的其他服务器，客户端也永远不会看到系统的较旧视图。 可靠性&ndash;应用更新后，此更新将一直持续到客户端覆盖更新为止。 及时性&ndash;保证系统的客户视图在特定时间内是最新的。  简单的API ZooKeeper的设计目标之一是提供一个非常简单的编程界面。因此，它仅支持以下操作：
 create：在树中的某个位置创建一个节点 delete：删除一个节点 exists：判断某个位置是否存在节点 get data：从节点读取数据 set data：将数据写入节点 get children：检索节点的子级列表 sync：等待数据传播  执行 ZooKeeper组件显示ZooKeeper服务的高级组件。除请求处理器外，构成ZooKeeper服务的每个服务器都复制其自己的每个组件副本。"><meta name=application-name content="arvin's blog"><meta name=apple-mobile-web-app-title content="arvin's blog"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://wzliy.github.io/posts/zookeeper%E5%AD%A6%E4%B9%A0/><link rel=prev href=https://wzliy.github.io/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/><link rel=next href=https://wzliy.github.io/posts/kafka%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/wzliy.github.io\/posts\/zookeeper%E5%AD%A6%E4%B9%A0\/"},"genre":"posts","wordcount":76,"url":"https:\/\/wzliy.github.io\/posts\/zookeeper%E5%AD%A6%E4%B9%A0\/","publisher":{"@type":"Organization","name":"作者"},"author":{"@type":"Person","name":"作者"},"description":""}</script></head><body header-desktop header-mobile><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':''==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:''==='dark')&&document.body.setAttribute('theme','dark')</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="arvin's blog">arvin's blog</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="arvin's blog">arvin's blog</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX"></h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>作者</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=0001-01-01>0001-01-01</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 76 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 1 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#zookeeper>Zookeeper</a><ul><li><a href=#概述>概述</a></li><li><a href=#快速开始>快速开始</a></li></ul></li></ul></nav></div></div><div class=content id=content><h2 id=zookeeper>Zookeeper</h2><p>zookeeper是针对分布式应用程序的高性能协调服务。它在一个简单的接口中提供了通用的服务-比如naming，configuration management，synchronization，group service，因此，你不必从头开始编写它们。你可以现成使用它来实现共识，组管理，领导者选举和状态协议。你也可以根据自己的特定需求在此基础上构建。</p><p>Zookeeper的典型应用场景：</p><ul><li>配置管理</li><li>DNS服务</li><li>组成员管理(group membership)</li><li>各种分布式锁</li></ul><p>Zookeeper适用于存储和协同相关的关键数据，不适合用于大数据量存储。</p><h3 id=概述>概述</h3><h4 id=zookeeper分布式应用程序的分布式协调服务>Zookeeper：分布式应用程序的分布式协调服务</h4><p>Zookeeper是一个分布式的，开源的协调服务，用于分布式应用程序，它提供了一组简单的原语，分布式应用程序可以基于这些原语来实现用于同步，配置维护以及组和命名空间的更高级别的服务。它被设计成易于编程的，并使用了按照文件系统熟悉的目录树结构样式设置的数据模型。它以Java运行，并且具有Java和C的绑定。</p><p>众所周知，协调服务很难做到。它们特别容易出现诸如竞态条件和死锁之类的错误。Zookeeper背后的动机是减轻分布式应用程序从头开始实施协调服务的责任。</p><h5 id=设计目标>设计目标</h5><p>Zookeeper是一个开源的分布式协调服务系统。Zookeeper的设计目标是将那些复杂且容易出错的分布式协同服务封装起来，抽象出一个高效可靠的原语集，并以一系列简单的接口提供给用户使用。</p><p><strong>ZooKeeper 是简单的</strong>。Zookeeper允许分布式进程通过共享的分层名称空间相互协调，该命名空间的组织方式类似于标准文件系统。命名空间由数据寄存器组成（Zookeeper中叫znode）组成，它们类似于文件和目录。与设计用于存储的典型文件系统不同，Zookeeper数据保留在内存中，这意味着Zookeeper可以实现高吞吐量和低延迟数。</p><p>Zookeeper的实现重视高性能、高可用、严格有序访问。Zookeeper的性能方面意味着它可以在大型的分布式系统中使用。可靠性方面使它不会成为单点故障。严格的有序意味着可以在客户端上实现复杂的同步原语。</p><p><strong>Zookeeper是可复制的</strong>。像它协调的分布式进程一样，Zookeeper本身也可以在称为集群的一组主机上进行复制。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://zookeeper.apache.org/doc/current/images/zkservice.jpg data-srcset="https://zookeeper.apache.org/doc/current/images/zkservice.jpg, https://zookeeper.apache.org/doc/current/images/zkservice.jpg 1.5x, https://zookeeper.apache.org/doc/current/images/zkservice.jpg 2x" data-sizes=auto alt=https://zookeeper.apache.org/doc/current/images/zkservice.jpg title="ZooKeeper Service"></p><p>组成Zookeeper服务的服务器都必须知道彼此。它们维护内存中的状态图像，以及持久化存储中的事务日志和快照。只要大多数服务器可用，Zookeeper服务将可用。</p><p>客户端连接到单个Zookeeper服务器。客户端维护一个TCP连接，通过该连接发送请求，获取响应，获取监视事件并发送心跳。如果与服务器的TCP连接断开，则客户端将连接到其他服务器。</p><p><strong>Zookeeper是有序的</strong>。Zookeeper用一个反映所有Zookeeper事务顺序的数字标记每个更新。后续操作可以使用该命令来实现更高级别的抽象，例如同步原语。</p><p><strong>Zookeeper是快速的</strong>。在"读取为主"的工作负载中，它特别快。Zookeeper应用程序可在数千台计算机上运行，并且在读取比写入更常见的情况下以10：1的比率运行效果最佳。</p><h5 id=zookeeper数据模型>Zookeeper数据模型</h5><p>Zookeeper提供的命名空间与标准文件系统的名称空间非常相似。名称是由斜杆（/）分隔的一系列路径元素。Zookeeper命名空间中的每个节点都由路径标识。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://zookeeper.apache.org/doc/current/images/zknamespace.jpg data-srcset="https://zookeeper.apache.org/doc/current/images/zknamespace.jpg, https://zookeeper.apache.org/doc/current/images/zknamespace.jpg 1.5x, https://zookeeper.apache.org/doc/current/images/zknamespace.jpg 2x" data-sizes=auto alt=https://zookeeper.apache.org/doc/current/images/zknamespace.jpg title="ZooKeeper&amp;rsquo;s Hierarchical Namespace"></p><p>Zookeeper的数据模型是层次模型。层次模型常见于文件系统。层次模型和key-value模型是两种主流的数据模型。Zookeeper使用文件系统模型主要基于以下两点考虑：</p><ol><li>文件系统的树形结构便于表达数据之间的层次关系；</li><li>文件系统的树形结构便于为不同的应用分配独立的命名空间(namespace)；</li></ol><p>Zookeeper的层次模型称为data tree。Data tree的每个节点叫做znode.不同于文件系统，每个节点都可以保存数据，每个节点都有一个版本，版本从0开始计数。</p><h5 id=节点和瞬时节点>节点和瞬时节点</h5><p>与标准文件系统不同，Zookeeper命名空间中的每个节点都可以具有与其关联的数据以及子节点。就像拥有一个文件系统一样，该文件系统也允许文件成为目录。（Zookeeper旨在存储协调数据：状态信息、配置、位置信息等，因此存储在每个节点上的数据通常很小，在千字节范围内。）我们使用术语znode来明确表示我们正在谈论Zookeeper数据节点。</p><p>Znodes维护一个统计信息结构，其中包括用于数据更改，ACL更改和时间戳的版本号，以允许进行缓存验证和协调更新。znode的数据每次更改时，版本号都会增加。例如，每当客户端检索数据时，它也接收数据的版本。</p><p>读取和写入存储在名称空间中每个znode上的数据都是原子操作。读取将获取与znode关联的所有数据字节，而写入将替换所有数据。每个节点都有一个访问控制列表（ACL），用于限制谁可以执行操作。</p><p>ZooKeeper还具有瞬时节点的概念。只要创建znode的会话处于活动状态，这些znode就存在。会话结束时，将删除znode。</p><h5 id=条件更新和监视器>条件更新和监视器</h5><p>ZooKeeper支持 <em>监视</em> 的概念。客户端可以在znode上设置监视器。znode更改时，将触发并删除监视。当触发监视后，客户端会收到一个数据包，说明znode已更改。如果客户端与其中一个ZooKeeper服务器之间的连接断开，则客户端将收到本地通知。</p><p>3.6.0中的新增功能：客户端还可以在znode上设置永久性的递归监视，这些监视在触发时不会删除，并且会以递归方式触发已注册znode以及所有子znode的更改。</p><h5 id=特性>特性</h5><p>ZooKeeper非常快速且非常简单。但是，由于其目标是作为构建更复杂的服务（例如同步）的基础，因此它提供了一组保证。它们是：</p><ul><li><strong>顺序一致性</strong>&ndash;来自客户端的更新将按照发送的顺序应用。</li><li><strong>原子性</strong>&ndash;全部更新成功或失败。没有部分结果。</li><li><strong>单个系统映像</strong>&ndash;无论客户端连接到哪个服务器，客户端都将看到该服务的相同视图。即，即使客户端故障转移到具有相同会话的其他服务器，客户端也永远不会看到系统的较旧视图。</li><li><strong>可靠性</strong>&ndash;应用更新后，此更新将一直持续到客户端覆盖更新为止。</li><li><strong>及时性</strong>&ndash;保证系统的客户视图在特定时间内是最新的。</li></ul><h5 id=简单的api>简单的API</h5><p>ZooKeeper的设计目标之一是提供一个非常简单的编程界面。因此，它仅支持以下操作：</p><ul><li>create：在树中的某个位置创建一个节点</li><li>delete：删除一个节点</li><li>exists：判断某个位置是否存在节点</li><li>get data：从节点读取数据</li><li>set data：将数据写入节点</li><li>get children：检索节点的子级列表</li><li>sync：等待数据传播</li></ul><h5 id=执行>执行</h5><p>ZooKeeper组件显示ZooKeeper服务的高级组件。除请求处理器外，构成ZooKeeper服务的每个服务器都复制其自己的每个组件副本。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://zookeeper.apache.org/doc/current/images/zkcomponents.jpg data-srcset="https://zookeeper.apache.org/doc/current/images/zkcomponents.jpg, https://zookeeper.apache.org/doc/current/images/zkcomponents.jpg 1.5x, https://zookeeper.apache.org/doc/current/images/zkcomponents.jpg 2x" data-sizes=auto alt=https://zookeeper.apache.org/doc/current/images/zkcomponents.jpg title="ZooKeeper Components"></p><p>replicated database是包含整个数据树的内存数据库。更新会记录到磁盘以确保可恢复性，并且将写入操作序列化到磁盘，在将其应用于内存数据库之前。</p><p>每个ZooKeeper服务器都为客户端提供服务。客户端仅连接到一台服务器即可提交请求。读取请求从每个服务器数据库的本地副本提供服务。更改服务状态的请求，写请求，由一个协议处理。</p><p>作为协议的一部分，来自客户端的所有写请求都转发到称为领导者的单个服务器。其余的ZooKeeper服务器（称为跟随者）从领导者接收消息建议并同意消息传递。消息传递层负责替换出现故障的领导者，并将跟随者与领导者同步。</p><p>ZooKeeper使用自定义的原子消息传递协议。由于消息传递层是原子层，因此ZooKeeper可以确保本地副本永远不会发散。领导者收到写请求时，它将计算要应用写操作时系统的状态，并将其转换为捕获此新状态的事务。</p><h5 id=作用>作用</h5><p>ZooKeeper的编程接口刻意简单。但是，有了它，您可以实现更高阶的操作，例如同步原语，组成员管理，所有权等。</p><h5 id=性能>性能</h5><p>ZooKeeper被设计为具有高性能。由于写入涉及同步所有服务器的状态，因此在读取数量多于写入的应用程序中，该功能特别高性能。（对于协调服务，通常情况下，读取次数多于写入次数。）</p><h5 id=可靠性>可靠性</h5><p>首先如果追随者失败并迅速恢复，那么即使失败，ZooKeeper也能够维持高吞吐量。但也许更重要的是，领导者选举算法允许系统恢复得足够快，以防止吞吐量大幅下降。根据我们的观察，ZooKeeper只需不到200毫秒即可选出新的领导者。第三，随着追随者的恢复，ZooKeeper能够在开始处理请求后再次提高吞吐量。</p><h3 id=快速开始>快速开始</h3></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 0001-01-01</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/ class=prev rel=prev title><i class="fas fa-angle-left fa-fw"></i></a><a href=/posts/kafka%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/ class=next rel=next title><i class="fas fa-angle-right fa-fw"></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.81.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i>LoveIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2021</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank></a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i></a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>