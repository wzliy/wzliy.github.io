<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>面试记录 - arvin's blog</title><meta name=Description content><meta property="og:title" content="面试记录"><meta property="og:description" content="面试遇到问题记录
 Spring Boot与Spring Cloud的区别 Spring Cloud的组成 怎么识别哪些数据需要缓存到Redis Maven怎么解决依赖冲突 如何优化Sql Mysql索引的数据结构 Mysql索引有什么缺点(比如一张表有十个字段，给十个字段都建立索引有什么问题) 分库如何查询的 多线程怎么使用的     Spring Boot 启动原理
  自定义启动类
  双亲委派机制
  Spring Bean的生命周期
  对象创建的过程
  垃圾回收算法
  自定义类加载器
  Redis的哨兵机制
  Kafka底层原理
  通过索引，怎么查询数据
  项目中有没有用到Spring Aop
  Spring Aop的实现原理
  面试整理 集合  经常用到哪些 Map 这几种 Map 的区别 ConcurrentHashMap 怎么保证线程安全 ConcurrentHashMap 在 JDK 1."><meta property="og:type" content="article"><meta property="og:url" content="https://wzliy.github.io/posts/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-04-13T09:00:00+08:00"><meta property="article:modified_time" content="2021-04-13T09:00:00+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="面试记录"><meta name=twitter:description content="面试遇到问题记录
 Spring Boot与Spring Cloud的区别 Spring Cloud的组成 怎么识别哪些数据需要缓存到Redis Maven怎么解决依赖冲突 如何优化Sql Mysql索引的数据结构 Mysql索引有什么缺点(比如一张表有十个字段，给十个字段都建立索引有什么问题) 分库如何查询的 多线程怎么使用的     Spring Boot 启动原理
  自定义启动类
  双亲委派机制
  Spring Bean的生命周期
  对象创建的过程
  垃圾回收算法
  自定义类加载器
  Redis的哨兵机制
  Kafka底层原理
  通过索引，怎么查询数据
  项目中有没有用到Spring Aop
  Spring Aop的实现原理
  面试整理 集合  经常用到哪些 Map 这几种 Map 的区别 ConcurrentHashMap 怎么保证线程安全 ConcurrentHashMap 在 JDK 1."><meta name=application-name content="arvin's blog"><meta name=apple-mobile-web-app-title content="arvin's blog"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://wzliy.github.io/posts/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/><link rel=prev href=https://wzliy.github.io/posts/java%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0/><link rel=next href=https://wzliy.github.io/posts/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"面试记录","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/wzliy.github.io\/posts\/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95\/"},"genre":"posts","wordcount":772,"url":"https:\/\/wzliy.github.io\/posts\/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95\/","datePublished":"2021-04-13T09:00:00+08:00","dateModified":"2021-04-13T09:00:00+08:00","publisher":{"@type":"Organization","name":"arvin"},"author":{"@type":"Person","name":"arvin"},"description":""}</script></head><body header-desktop header-mobile><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':''==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:''==='dark')&&document.body.setAttribute('theme','dark')</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="arvin's blog">arvin's blog</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="arvin's blog">arvin's blog</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">面试记录</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>arvin</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2021-04-13>2021-04-13</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 772 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 4 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><ul><li></li></ul></li></ul></nav></div></div><div class=content id=content><p>面试遇到问题记录</p><ul><li>Spring Boot与Spring Cloud的区别</li><li>Spring Cloud的组成</li><li>怎么识别哪些数据需要缓存到Redis</li><li>Maven怎么解决依赖冲突</li><li>如何优化Sql</li><li>Mysql索引的数据结构</li><li>Mysql索引有什么缺点(比如一张表有十个字段，给十个字段都建立索引有什么问题)</li><li>分库如何查询的</li><li>多线程怎么使用的</li></ul><hr><ul><li><p>Spring Boot 启动原理</p></li><li><p>自定义启动类</p></li><li><p>双亲委派机制</p></li><li><p>Spring Bean的生命周期</p></li><li><p>对象创建的过程</p></li><li><p>垃圾回收算法</p></li><li><p>自定义类加载器</p></li><li><p>Redis的哨兵机制</p></li><li><p>Kafka底层原理</p></li><li><p>通过索引，怎么查询数据</p></li><li><p>项目中有没有用到Spring Aop</p></li><li><p>Spring Aop的实现原理</p></li></ul><h4 id=面试整理>面试整理</h4><h6 id=集合>集合</h6><ul><li>经常用到哪些 Map</li><li>这几种 Map 的区别</li><li>ConcurrentHashMap 怎么保证线程安全</li><li>ConcurrentHashMap 在 JDK 1.8 前后的锁有什么区别</li><li>聊下 HashMap 的原理</li><li>HashMap 在 Put 时，新链表节点是放在头部还是尾部</li><li>HashMap 扩容时的流程</li><li>HashMap 在 JDK 1.8 有什么改变</li><li>ConcurrentHashMap 在 JDK 1.8 有什么改变</li><li>TreeMap 的原理</li><li>Map、List、Set 分别说下你知道的线程安全类和线程不安全的类</li></ul><h6 id=多线程锁>多线程、锁</h6><ul><li>线程池使用的是哪种</li><li>线程池参数怎么配置</li><li>线程池各个参数的作用</li><li>线程池的参数配置要注意什么</li><li>线程池的工作流程</li><li>JDK 中的并发类知道哪些</li><li>AQS 的底层原理</li><li>介绍下悲观锁和乐观锁</li><li>使用过哪些锁</li><li>synchronized 和 Lock 的区别、使用场景</li><li>synchronized 原理</li><li>synchronized 作用于静态方法、普通方法、this、Lock.class 的区别</li><li>为什么引入偏向锁、轻量级锁，介绍下升级流程</li><li>死锁的必要条件，如何预防死锁</li><li>介绍下 CountDownLatch 和 CyclicBarrier</li><li>介绍下 CAS，存在什么问题</li><li>介绍下 ThreadLocal，存在什么问题</li></ul><h6 id=网络>网络</h6><ul><li><p>HTTPS 是怎么加密的</p></li><li><p>普通 Hash 和一致性 Hash 原理</p></li><li><p>一致性 Hash 的缺点</p></li><li><p>TCP 三次握手过程，为什么需要三次握手</p></li><li><p>为什么 TIME_WAIT 状态需要经过 2MSL 才能返回到 CLOSE 状态</p></li><li><p>TCP 的拥塞控制</p></li><li><p>TCP 如何解决流控、乱序、丢包问题</p></li><li><p>为什么会出现粘包和拆包，如何解决</p></li></ul><h6 id=springmybatis>Spring、MyBatis</h6><ul><li>Mybatis 中 # 和 $ 的区别</li><li>怎么防止 SQL 注入</li><li>使用 Mybatis 时，调用 DAO（Mapper）接口时是怎么调用到 SQL 的</li><li>介绍下 Spring IoC 的流程</li><li>BeanFactory 和 FactoryBean 的区别</li><li>Spring 的 AOP 是怎么实现的</li><li>Spring 的事务传播行为有哪些，讲下嵌套事务</li><li>什么情况下对象不能被代理</li><li>Spring 怎么解决循环依赖的问题</li><li>要在 Spring IoC 容器构建完毕之后执行一些逻辑，怎么实现</li><li>@Resource 和 @Autowire 的区别</li><li>@Autowire 怎么使用名称来注入</li><li>bean 的 init-method 属性指定的方法里用到了其他 bean 实例，会有问题吗</li><li>@PostConstruct 修饰的方法里用到了其他 bean 实例，会有问题吗</li><li>Spring 中，有两个 id 相同的 bean，会报错吗，如果会报错，在哪个阶段报错</li><li>Spring 中，bean 的 class 属性指定了一个不存在的 class，会报错吗，如果会报错，在哪个阶段</li><li>Spring 中的常见扩展点有哪些</li></ul><h6 id=mysql>MySQL</h6><ul><li>MySQL 索引的数据结构</li><li>为什么使用 B+ 树，与其他索引相比有什么优点</li><li>各种索引之间的区别</li><li>B+ 树在进行范围查找时怎么处理</li><li>MySQL 索引叶子节点存放的是什么</li><li>联合索引（复合索引）的底层实现</li><li>MySQL 如何锁住一行数据</li><li>SELECT 语句能加互斥锁吗</li><li>多个事务同时对一行数据进行 SELECT FOR UPDATE 会阻塞还是异常</li><li>MySQL 使用的版本和执行引擎</li><li>MySQL 不同执行引擎的区别</li><li>MySQL 的事务隔离级别</li><li>MySQL 的可重复读是怎么实现的</li><li>MySQL 是否会出现幻读</li><li>MySQL 的 gap 锁</li><li>MySQL 的主从同步原理</li><li>分库分表的实现方案</li><li>分布式唯一 ID 方案</li><li>如何优化慢查询</li><li>explain 中每个字段的意思</li><li>explain 中的 type 字段有哪些常见的值</li><li>explain 中你通常关注哪些字段，为什么</li></ul><h6 id=jvm>JVM</h6><ul><li>运行时数据区</li><li>服务器使用的什么垃圾收集器</li><li>CMS 垃圾收集的原理</li><li>G1 垃圾收集的特点，为什么低延迟</li><li>有哪些垃圾回收算法，优缺点</li><li>哪些对象可以作为 GC Roots</li><li>有哪些类加载器</li><li>双亲委派模式，哪些场景是打破双亲委派模式</li><li>线上服务器出现频繁 Full GC，怎么排查</li><li>定位问题常用哪些命令</li><li>介绍下 JVM 调优的过程</li></ul><h6 id=kafka>Kafka</h6><ul><li>为什么使用 Kafka</li><li>介绍下 Kafka 的各个组件</li><li>如何保证写入 Kafka 的数据不丢失</li><li>如何保证从 Kafka 消费的数据不丢失</li><li>Kafka 为什么性能这么高</li><li>零拷贝技术使用哪个方法实现</li><li>Java 中也有类似的零拷贝技术，是哪个方法</li><li>Kafka 怎么保证消息的顺序消费</li><li>Kafka 怎么避免重复消费</li><li>什么是 HighWatermark 和 LEO</li><li>什么是 ISR，为什么需要引入 ISR</li></ul><h6 id=redis>Redis</h6><ul><li>项目中使用的 Redis 版本</li><li>Redis 在项目中的使用场景</li><li>Redis 怎么保证高可用</li><li>Redis 的选举流程</li><li>Redis 和 Memcache 的区别</li><li>Redis 的集群模式</li><li>Redis 集群要增加分片，槽的迁移怎么保证无损</li><li>Redis 分布式锁的实现</li><li>Redis 删除过期键的策略</li><li>Redis 的内存淘汰策略</li><li>Redis 的 Hash 对象底层结构</li><li>Redis 中 Hash 对象的扩容流程</li><li>Redis 的 Hash 对象的扩容流程在数据量大的时候会有什么问题吗</li><li>Redis 的持久化机制有哪几种</li><li>RDB 和 AOF 的实现原理、优缺点</li><li>AOF 重写的过程</li><li>哨兵模式的原理</li><li>使用缓存时，先操作数据库还是先操作缓存</li><li>为什么是让缓存失效，而不是更新缓存</li><li>缓存穿透、缓存击穿、缓存雪崩</li><li>更新缓存的几种设计模式</li></ul><h6 id=zookeeper>Zookeeper</h6><ul><li>Zookeeper 的使用场景</li><li>Zookeeper 怎么实现分布式锁</li><li>Zookeeper 怎么保证数据的一致性</li><li>ZAB 协议的原理</li><li>Zookeeper 遵循 CAP 中的哪些</li><li>Zookeeper 和 Eureka 的区别</li><li>Zookeeper 的 Leader 选举</li><li>Observer 的作用</li><li>Leader 发送了 commit 消息，但是所有的 follower 都没有收到这条消息，Leader 就挂了，后续会怎么处理</li></ul><h6 id=分布式>分布式</h6><ul><li>CAP 理论</li><li>BASE 理论</li><li>分布式事务 2PC 和 TCC 的原理</li><li>TCC 在 cancel 阶段如果出现失败怎么处理</li><li>Paxos 算法、Raft 算法</li></ul><h4 id=问题详解>问题详解</h4><h5 id=集合-1>集合</h5><blockquote><p>经常用到哪些 Map</p></blockquote><p>LinkedHashMap、ConcurrentHashMap、TreeMap、HashMap</p><blockquote><p>这几种 Map 的区别</p></blockquote><p>ConcurrentHashMap是线程安全的</p><p>LinkedHashMap可以记录插入顺序和访问顺序</p><p>TreeMap可以自定义排序</p><p>除了这几个场景，其他场景都能使用HashMap</p><blockquote><p>ConcurrentHashMap 怎么保证线程安全</p></blockquote><p>JDK1.8之前是通过分段加锁，JDK1.8之后是通过CAS+Synchronize</p><p>分段锁：就是将内部进行分段（Segment），里面存放的也是跟HashMap类似的HashEntry数组，利用分段设计，在进行并发操作的时候，只需要锁定相应的段，这样就有效避免了整体同步的问题，大大提高了性能</p><blockquote><p>ConcurrentHashMap 在 JDK 1.8 前后的锁有什么区别</p></blockquote><p>JDK1.8以前使用Segment将内部进行分段，JDK1.8之后，Segment不再有任何结构上的用处，使用Synchronize同步代码块，数据存储利用volatile来保证可见性，使用CAS等操作，在特定场景进行无锁并发操作。</p><blockquote><p>聊下 HashMap 的原理</p></blockquote><p>HashMap内部是数组和链表组成的复合结构，数组被分为一个个桶，通过哈希值决定了键值对在这个数组的寻址；哈希值相同的键值对，则以链表形式存储，如果链表大小超过阈值(8)，会将链表转成红黑树存储。</p><blockquote><p>HashMap 在 Put 时，新链表节点是放在头部还是尾部</p></blockquote><p>JDK1.8以前是放在头部，JDK1.8之后是插入的链表尾部</p><blockquote><p>HashMap 扩容时的流程</p></blockquote><p>HashMap扩容发生在达到阈值时，阈值就是容量*负载因子</p><p>HashMap的默认初始容量大小16，HashMap的最大容量 ：2的30次方</p><p>当数组中数据的个数超过总数的0.75时，HashMap就会自动扩容，扩容到原数组容量的两倍。</p><p>jdk1.7扩容是重新计算hash；jdk1.8是要看看原来的hash值新增的那个bit是1还是0好了，如果是0则索引没变，如果是1则索引变成"原索引+oldCap"</p><blockquote><p>HashMap 在 JDK 1.8 有什么改变</p></blockquote><blockquote><p>CocurrentHashMap 在 JDK 1.8 有什么改变</p></blockquote><blockquote><p>TreeMap 的原理</p></blockquote><p>TreeMap是基于红黑树的一种提供顺序访问的Map,具体的顺序可以由指定的Comparator决定，或者根据键的自然顺序来判断</p><blockquote><p>Map、List、Set 分别说下你知道的线程安全类和线程不安全的类</p></blockquote><h5 id=多线程>多线程</h5><blockquote><p>线程池使用的是哪种</p></blockquote><p>线程池通常都是利用Executors提供的通用线程池创建方法，去创建不同配置的线程池，主要区别在于不同的ExecutorService类型或者不同的初始参数，有5种不同的线程池创建配置</p><p>newCachedThreadPool()</p><p>newFixedThreadPool(int nThreads)</p><p>newSingleThreadExecutor()</p><p>newSingleThreadScheduledExecutor() 和 newScheduledThreadPool(int corePoolSize)</p><p>newWorkStealingPool(int parallelism)</p><blockquote><p>线程池参数怎么配置</p></blockquote><p>corePoolSize: 核心线程数大小</p><p>maximumPoolSize: 最大线程数</p><p>keepAliveTime: 存活时间</p><p>unit: keepAliveTime的时间单位</p><p>workQuene: 存放待执行任务的队列</p><p>threadFactory: 线程工厂</p><p>handler: 拒绝策略</p><p>一般先区分你的任务CPU密集型还是IO密集型，CPU密集型任务配置尽可能少的线程数量，一般公式：CPU核数 + 1 线程的线程池；IO密集型：大部分的线程都阻塞，故需要多配置线程数</p><blockquote><p>线程池各个参数的作用</p></blockquote><p>1.<em>corePoolSize</em>：</p><p>（核心线程数大小：不管它们创建以后是不是空闲的。线程池需要保持 corePoolSize 数量的线程，除非设置了 allowCoreThreadTimeOut。）</p><p>2.<em>maximumPoolSize</em>：</p><p>（最大线程数：线程池中最多允许创建 maximumPoolSize 个线程。）</p><p>3.<em>keepAliveTime</em>：</p><p>（存活时间：如果经过 keepAliveTime 时间后，超过核心线程数的线程还没有接受到新的任务，那就回收。）</p><p>4.<em>unit</em>：</p><p>（keepAliveTime 的时间单位。）</p><p>5.<em>workQueue</em>：</p><p>（存放待执行任务的队列：当提交的任务数超过核心线程数大小后，再提交的任务就存放在这里。它仅仅用来存放被 execute 方法提交的 Runnable 任务。）</p><p>6.<em>threadFactory</em>：</p><p>（线程工厂：用来创建线程工厂。比如这里面可以自定义线程名称，当进行虚拟机栈分析时，看着名字就知道这个线程是哪里来的，不会懵逼。）</p><p>7.<em>handler</em> ：</p><p>（拒绝策略：当队列里面放满了任务、最大线程数的线程都在工作时，这时继续提交的任务线程池就处理不了，应该执行怎么样的拒绝策略。）</p><blockquote><p>线程池的参数配置要注意什么</p></blockquote><p>主要注意的是这几个参数：<strong>corePoolSize、maximumPoolSize、workQueue（队列长度）</strong></p><blockquote><p>线程池的工作流程</p></blockquote><p>提交任务，判断线程池是否在运行，如果还在运行，就判断线程数是否小于核心数，否则拒绝任务，如果线程数小于核心数，就添加工作线程并执行，如果线程数超过了核心线程数，就判断阻塞队列是否已满，如果没有满，就添加阻塞队列等待工作线程获取执行，如果阻塞队列已满，就判断线程数是否小于最大线程数，如果小于，就添加工作线程并执行，如果不小于，就拒绝任务</p><blockquote><p>JDK 中的并发类知道哪些</p></blockquote><p>提供了比 synchronized 更加高级的各种同步结构，包括 CountDownLatch、CyclicBarrier、Semaphore 等，可以实现更加丰富的多线程操作，比如利用 Semaphore 作为资源控制器，限制同时进行工作的线程数量。</p><p>各种线程安全的容器，比如最常见的 ConcurrentHashMap、有序的 ConcurrentSkipListMap，或者通过类似快照机制，实现线程安全的动态数组 CopyOnWriteArrayList 等。</p><p>各种并发队列实现，如各种 BlockingQueue 实现，比较典型的 ArrayBlockingQueue、 SynchronousQueue 或针对特定场景的 PriorityBlockingQueue 等。</p><p>强大的 Executor 框架，可以创建各种不同类型的线程池，调度任务运行等，绝大部分情况下，不再需要自己从头实现线程池和任务调度器。</p><blockquote><p>AQS 的底层原理</p></blockquote><blockquote><p>介绍下悲观锁和乐观锁</p></blockquote><blockquote><p>使用过哪些锁</p></blockquote><blockquote><p>synchronized 和 Lock 的区别、使用场景</p></blockquote><blockquote><p>synchronized 原理</p></blockquote><blockquote><p>synchronized 作用于静态方法、普通方法、this、Lock.class 的区别</p></blockquote><blockquote><p>为什么引入偏向锁、轻量级锁，介绍下升级流程</p></blockquote><blockquote><p>死锁的必要条件，如何预防死锁</p></blockquote><blockquote><p>介绍下 CountDownLatch 和 CyclicBarrier</p></blockquote><blockquote><p>介绍下 CAS，存在什么问题</p></blockquote><p>CAS就是一些列操作的集合，获取当前数值，进行一些运算，利用 CAS 指令试图进行更新。如果当前数值未变，代表没有其他线程进行并发修改，则成功更新。否则，可能出现不同的选择，要么进行重试，要么就返回一个成功或者失败的结果。</p><p>CAS存在的问题，一个是它的失败重试机制，隐含着一个假设，即竞争情况是短暂的。大多数应用场景中，确实大部分重试只会发生一次就获得了成功，但是总是有意外情况，所以在有需要的时候，还是要考虑限制自旋的次数，以免过度消耗 CPU。另外一个就是著名的ABA问题，这是通常只在 lock-free 算法下暴露的问题。CAS 是在更新时比较前值，如果对方只是恰好相同，例如期间发生了 A -> B -> A 的更新，仅仅判断数值是 A，可能导致不合理的修改操作。针对这种情况，Java 提供了 AtomicStampedReference 工具类，通过为引用建立类似版本号（stamp）的方式，来保证 CAS 的正确性。</p><blockquote><p>介绍下 ThreadLocal，存在什么问题</p></blockquote><h5 id=jvm-1>JVM</h5><h5 id=设计模式>设计模式</h5><h5 id=spring>Spring</h5><blockquote><p>介绍下 Spring IoC 的流程</p></blockquote><p>主要初始化Spring IoC容器，包括BeanDefinition的Resource定位、载入、注册三个基本过程。</p><p>BeanDefinition的资源定位过程就是找到定义的javabean信息，并将其封装成Resource对象</p><p>BeanDefinition的载入和解析就是把用户定义好的Javabean表示为IoC容器内部的数据结构，这个容器内部的数据结构就是BeanDefinition</p><p>BeanDefinition在IoC容器中的注册就是向IoC容器注册这些BeanDefinition，完成了BeanDefinition的注册，就完成了IoC容器的初始化过程。此时，在使用的IoC容器DefaultListableBeanFactory中已经建立了整个Bean的配置信息，而且这些BeanDefinition已经可以被容器使用了。容器的作用就是对这些信息进行处理和维护，这些信息是容器建立依赖反转的基础。</p><blockquote><p>BeanFactory 和 FactoryBean 的区别</p></blockquote><p>BeanFactory定义了IOC容器的最基本形式，并提供了IOC容器应遵守的的最基本的接口，也就是Spring IOC所遵守的最底层和最基本的编程规范。在Spring代码中，BeanFactory只是个接口，并不是IOC容器的具体实现。</p><p>一般情况下，Spring通过反射机制利用bean的class属性指定实现类实例化Bean，在某些情况下，实例化Bean过程比较复杂，如果按照传统的方式，则需要在中提供大量的配置信息。配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。Spring为此提供了一个FactoryBean的工厂类接口，用户可以通过实现该接口定制实例化Bean的逻辑。
BeanFactory是个Factory，也就是IOC容器或对象工厂，FactoryBean是个Bean，但它是一个能生产或者修饰对象生成的工厂bean。</p><blockquote><p>Spring 的 AOP 是怎么实现的</p></blockquote><p>Spring AOP 使用的是动态代理，所谓的动态代理就是说 AOP 框架不会去修改字节码，而是在内存中临时为方法生成一个 AOP 对象，这个 AOP 对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法 。</p><p>Spring AOP 中的动态代理主要有两种方式， JDK 动态代理和 CGLIB 动态代理 。</p><p>* JDK 动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口 。JDK 动态代理的核心是 InvocationHandler 接口和 Proxy 类 。</p><p>* 如果目标类没有实现接口，那么 Spring AOP 会选择使用 CGLIB 来动态代理目标类 。CGLIB （ Code Generation Library ），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意， CGLIB 是通过继承的方式做的动态代理，因此如果某个类被标记为 final ，那么它是无法使用 CGLIB 做动态代理的 。</p><blockquote><p>Spring bean的生命周期</p></blockquote><p>Bean的生命周期分为四个阶段：</p><p>实例化</p><p>属性赋值</p><p>初始化</p><p>销毁</p><p>但有非常多的扩展点用于Bean的生命周期，主要可以分为两类扩展点，一类是作用于多个Bean的，分为InstantiationAwareBeanPostProcessor和BeanPostProcessor, InstantiationAwareBeanPostProcessor作用于实例化前后，BeanPostProcessor作用于初始化前后，一类是影响单个Bean的只调用一次的接口，主要是Aware接口</p><blockquote><p>Spring 的事务传播行为有哪些，讲下嵌套事务</p></blockquote><blockquote><p>什么情况下对象不能被代理</p></blockquote><blockquote><p>Spring 怎么解决循环依赖的问题</p></blockquote><p>在Spring中，对象的实例化是通过反射实现的，而对象的属性则是在对象实例化之后通过一定的方式设置的。Spring为了解决单例的循环依赖问题，使用了三级缓存。</p><p>这三级缓存分别指：</p><ul><li>singletonFactories ：单例对象工厂的cache</li><li>earlySingletonObjects ：提前暴光的单例对象的Cache</li><li>singletonObjects：单例对象的cache</li></ul><p>在创建bean的时候，首先想到的是从cache中获取这个单例的bean，这个缓存就是singletonObjects。如果获取不到，并且对象正在创建中，就再从二级缓存earlySingletonObjects中获取。如果还是获取不到且允许singletonFactories通过getObject()获取，就从三级缓存singletonFactory.getObject()(三级缓存)获取，如果获取到了则：从singletonFactories中移除，并放入earlySingletonObjects中。其实也就是从三级缓存移动到了二级缓存。</p><blockquote><p>要在 Spring IoC 容器构建完毕之后执行一些逻辑，怎么实现</p></blockquote><blockquote><p>@Resource 和 @Autowire 的区别</p></blockquote><blockquote><p>@Autowire 怎么使用名称来注入</p></blockquote><blockquote><p>bean 的 init-method 属性指定的方法里用到了其他 bean 实例，会有问题吗</p></blockquote><blockquote><p>@PostConstruct 修饰的方法里用到了其他 bean 实例，会有问题吗</p></blockquote><blockquote><p>Spring 中，有两个 id 相同的 bean，会报错吗，如果会报错，在哪个阶段报错</p></blockquote><blockquote><p>Spring 中，bean 的 class 属性指定了一个不存在的 class，会报错吗，如果会报错，在哪个阶段</p></blockquote><blockquote><p>Spring 中的常见扩展点有哪些</p></blockquote><h5 id=springboot>SpringBoot</h5><h5 id=springcloud>SpringCloud</h5><h5 id=mysql-1>Mysql</h5><blockquote><p>MySQL 索引的数据结构</p></blockquote><p>mysql索引的数据结构是树，常用的存储引擎innodb采用的是B+Tree</p><blockquote><p>为什么使用 B+ 树，与其他索引相比有什么优点</p></blockquote><p>B+树是B树的变体，相对于B树，叶子结点的值包含了所有的值，所有父结点的值是重复了叶子结点的值，</p><p>父结点只起索引查找的作用，同时所叶子结点也也构成了一条有序的链表。</p><p>B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少，从而导致树的高度增加，IO操作变多，查询性能变低，而B+树的高度一般只有1-3</p><blockquote><p>各种索引之间的区别</p></blockquote><p>主键索引: mysql会为每个表的主键自动添加索引，在其索引树的叶子节点中，保存着主键所在行的所有数据</p><p>唯一索引: 其数据不可重复,不同的是其索引树的叶子节点保存的不是所在行的所有数据，而是该列的值</p><p>普通索引: 其值可以重复，而且索引树叶子节点保存的就是该列的值，而不是整行数据</p><p>聚合索引: 因为每个索引对应一棵索引树</p><blockquote><p>B+ 树在进行范围查找时怎么处理</p></blockquote><p>找到起始叶子节点，包括范围起始值，沿着叶的链接读下一个节点，直到遇到范围终止值</p><blockquote><p>MySQL 索引叶子节点存放的是什么</p></blockquote><p>B+树结构的索引，主键索引的叶子节点保存了该行的所有数据，普通索引存放的是主键的值</p><blockquote><p>索引的查询过程</p></blockquote><p>如果是主键索引，通过索引查询到叶子节点，主键索引的叶子节点保存了该行的所有数据，直接返回就可以了；如果是普通索引，通过索引查询到叶子节点后，由于普通索引的叶子节点保存的是主键的值，还要根据主键的值去主键索引中查询数据，这个查询过程就称之为回表。</p><blockquote><p>联合索引（复合索引）的底层实现</p></blockquote><p>联合索引也是一棵B+树，索引值保存了多个列的值，键值也是排序的，但它是按最左原则排的序。</p><blockquote><p>MySQL 如何锁住一行数据</p></blockquote><p>在SQL语句后面加上for update.</p><blockquote><p>SELECT 语句能加互斥锁吗</p></blockquote><blockquote><p>多个事务同时对一行数据进行 SELECT FOR UPDATE 会阻塞还是异常</p></blockquote><blockquote><p>MySQL 使用的版本和执行引擎</p></blockquote><blockquote><p>MySQL 不同执行引擎的区别</p></blockquote><blockquote><p>MySQL 的事务隔离级别</p></blockquote><blockquote><p>MySQL 的可重复读是怎么实现的</p></blockquote><blockquote><p>MySQL 是否会出现幻读</p></blockquote><blockquote><p>MySQL 的 gap 锁</p></blockquote><blockquote><p>MySQL 的主从同步原理</p></blockquote><blockquote><p>分库分表的实现方案</p></blockquote><p>使用hash进行路由策略</p><blockquote><p>分布式唯一 ID 方案</p></blockquote><blockquote><p>如何优化慢查询</p></blockquote><blockquote><p>explain 中每个字段的意思</p></blockquote><blockquote><p>explain 中的 type 字段有哪些常见的值</p></blockquote><blockquote><p>explain 中你通常关注哪些字段，为什么</p></blockquote><h5 id=mybatis>MyBatis</h5><h5 id=redis-1>Redis</h5><h5 id=zookeeper-1>Zookeeper</h5><h5 id=消息队列>消息队列</h5><h5 id=分布式-1>分布式</h5></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2021-04-13</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/java%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0/ class=prev rel=prev title=Java并发学习><i class="fas fa-angle-left fa-fw"></i>Java并发学习</a>
<a href=/posts/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/ class=next rel=next title=网络通信>网络通信<i class="fas fa-angle-right fa-fw"></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.81.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i>LoveIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2021</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank></a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i></a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>