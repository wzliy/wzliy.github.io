<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>面试记录 - arvin's blog</title><meta name=Description content><meta property="og:title" content="面试记录"><meta property="og:description" content="面试遇到问题记录
 Spring Boot与Spring Cloud的区别 Spring Cloud的组成 怎么识别哪些数据需要缓存到Redis Maven怎么解决依赖冲突 如何优化Sql Mysql索引的数据结构 Mysql索引有什么缺点(比如一张表有十个字段，给十个字段都建立索引有什么问题) 分库如何查询的 多线程怎么使用的     Spring Boot 启动原理
  自定义启动类
  双亲委派机制
  Spring Bean的生命周期
  对象创建的过程
  垃圾回收算法
  自定义类加载器
  Redis的哨兵机制
  Kafka底层原理
  通过索引，怎么查询数据
  项目中有没有用到Spring Aop
  Spring Aop的实现原理
  面试整理 集合  经常用到哪些 Map 这几种 Map 的区别 ConcurrentHashMap 怎么保证线程安全 ConcurrentHashMap 在 JDK 1."><meta property="og:type" content="article"><meta property="og:url" content="https://wzliy.github.io/posts/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-04-13T09:00:00+08:00"><meta property="article:modified_time" content="2021-04-13T09:00:00+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="面试记录"><meta name=twitter:description content="面试遇到问题记录
 Spring Boot与Spring Cloud的区别 Spring Cloud的组成 怎么识别哪些数据需要缓存到Redis Maven怎么解决依赖冲突 如何优化Sql Mysql索引的数据结构 Mysql索引有什么缺点(比如一张表有十个字段，给十个字段都建立索引有什么问题) 分库如何查询的 多线程怎么使用的     Spring Boot 启动原理
  自定义启动类
  双亲委派机制
  Spring Bean的生命周期
  对象创建的过程
  垃圾回收算法
  自定义类加载器
  Redis的哨兵机制
  Kafka底层原理
  通过索引，怎么查询数据
  项目中有没有用到Spring Aop
  Spring Aop的实现原理
  面试整理 集合  经常用到哪些 Map 这几种 Map 的区别 ConcurrentHashMap 怎么保证线程安全 ConcurrentHashMap 在 JDK 1."><meta name=application-name content="arvin's blog"><meta name=apple-mobile-web-app-title content="arvin's blog"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://wzliy.github.io/posts/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/><link rel=prev href=https://wzliy.github.io/posts/java%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0/><link rel=next href=https://wzliy.github.io/posts/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"面试记录","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/wzliy.github.io\/posts\/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95\/"},"genre":"posts","wordcount":900,"url":"https:\/\/wzliy.github.io\/posts\/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95\/","datePublished":"2021-04-13T09:00:00+08:00","dateModified":"2021-04-13T09:00:00+08:00","publisher":{"@type":"Organization","name":"arvin"},"author":{"@type":"Person","name":"arvin"},"description":""}</script></head><body header-desktop header-mobile><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':''==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:''==='dark')&&document.body.setAttribute('theme','dark')</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="arvin's blog">arvin's blog</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="arvin's blog">arvin's blog</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">面试记录</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>arvin</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2021-04-13>2021-04-13</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 900 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 5 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><ul><li></li></ul></li></ul></nav></div></div><div class=content id=content><p>面试遇到问题记录</p><ul><li>Spring Boot与Spring Cloud的区别</li><li>Spring Cloud的组成</li><li>怎么识别哪些数据需要缓存到Redis</li><li>Maven怎么解决依赖冲突</li><li>如何优化Sql</li><li>Mysql索引的数据结构</li><li>Mysql索引有什么缺点(比如一张表有十个字段，给十个字段都建立索引有什么问题)</li><li>分库如何查询的</li><li>多线程怎么使用的</li></ul><hr><ul><li><p>Spring Boot 启动原理</p></li><li><p>自定义启动类</p></li><li><p>双亲委派机制</p></li><li><p>Spring Bean的生命周期</p></li><li><p>对象创建的过程</p></li><li><p>垃圾回收算法</p></li><li><p>自定义类加载器</p></li><li><p>Redis的哨兵机制</p></li><li><p>Kafka底层原理</p></li><li><p>通过索引，怎么查询数据</p></li><li><p>项目中有没有用到Spring Aop</p></li><li><p>Spring Aop的实现原理</p></li></ul><h4 id=面试整理>面试整理</h4><h6 id=集合>集合</h6><ul><li>经常用到哪些 Map</li><li>这几种 Map 的区别</li><li>ConcurrentHashMap 怎么保证线程安全</li><li>ConcurrentHashMap 在 JDK 1.8 前后的锁有什么区别</li><li>聊下 HashMap 的原理</li><li>HashMap 在 Put 时，新链表节点是放在头部还是尾部</li><li>HashMap 扩容时的流程</li><li>HashMap 在 JDK 1.8 有什么改变</li><li>ConcurrentHashMap 在 JDK 1.8 有什么改变</li><li>TreeMap 的原理</li><li>Map、List、Set 分别说下你知道的线程安全类和线程不安全的类</li></ul><h6 id=多线程锁>多线程、锁</h6><ul><li>线程池使用的是哪种</li><li>线程池参数怎么配置</li><li>线程池各个参数的作用</li><li>线程池的参数配置要注意什么</li><li>线程池的工作流程</li><li>JDK 中的并发类知道哪些</li><li>AQS 的底层原理</li><li>介绍下悲观锁和乐观锁</li><li>使用过哪些锁</li><li>synchronized 和 Lock 的区别、使用场景</li><li>synchronized 原理</li><li>synchronized 作用于静态方法、普通方法、this、Lock.class 的区别</li><li>为什么引入偏向锁、轻量级锁，介绍下升级流程</li><li>死锁的必要条件，如何预防死锁</li><li>介绍下 CountDownLatch 和 CyclicBarrier</li><li>介绍下 CAS，存在什么问题</li><li>介绍下 ThreadLocal，存在什么问题</li></ul><h6 id=网络>网络</h6><ul><li><p>HTTPS 是怎么加密的</p></li><li><p>普通 Hash 和一致性 Hash 原理</p></li><li><p>一致性 Hash 的缺点</p></li><li><p>TCP 三次握手过程，为什么需要三次握手</p></li><li><p>为什么 TIME_WAIT 状态需要经过 2MSL 才能返回到 CLOSE 状态</p></li><li><p>TCP 的拥塞控制</p></li><li><p>TCP 如何解决流控、乱序、丢包问题</p></li><li><p>为什么会出现粘包和拆包，如何解决</p></li></ul><h6 id=springmybatis>Spring、MyBatis</h6><ul><li>Mybatis 中 # 和 $ 的区别</li><li>怎么防止 SQL 注入</li><li>使用 Mybatis 时，调用 DAO（Mapper）接口时是怎么调用到 SQL 的</li><li>介绍下 Spring IoC 的流程</li><li>BeanFactory 和 FactoryBean 的区别</li><li>Spring 的 AOP 是怎么实现的</li><li>Spring 的事务传播行为有哪些，讲下嵌套事务</li><li>什么情况下对象不能被代理</li><li>Spring 怎么解决循环依赖的问题</li><li>要在 Spring IoC 容器构建完毕之后执行一些逻辑，怎么实现</li><li>@Resource 和 @Autowire 的区别</li><li>@Autowire 怎么使用名称来注入</li><li>bean 的 init-method 属性指定的方法里用到了其他 bean 实例，会有问题吗</li><li>@PostConstruct 修饰的方法里用到了其他 bean 实例，会有问题吗</li><li>Spring 中，有两个 id 相同的 bean，会报错吗，如果会报错，在哪个阶段报错</li><li>Spring 中，bean 的 class 属性指定了一个不存在的 class，会报错吗，如果会报错，在哪个阶段</li><li>Spring 中的常见扩展点有哪些</li></ul><h6 id=mysql>MySQL</h6><ul><li>MySQL 索引的数据结构</li><li>为什么使用 B+ 树，与其他索引相比有什么优点</li><li>各种索引之间的区别</li><li>B+ 树在进行范围查找时怎么处理</li><li>MySQL 索引叶子节点存放的是什么</li><li>联合索引（复合索引）的底层实现</li><li>MySQL 如何锁住一行数据</li><li>SELECT 语句能加互斥锁吗</li><li>多个事务同时对一行数据进行 SELECT FOR UPDATE 会阻塞还是异常</li><li>MySQL 使用的版本和执行引擎</li><li>MySQL 不同执行引擎的区别</li><li>MySQL 的事务隔离级别</li><li>MySQL 的可重复读是怎么实现的</li><li>MySQL 是否会出现幻读</li><li>MySQL 的 gap 锁</li><li>MySQL 的主从同步原理</li><li>分库分表的实现方案</li><li>分布式唯一 ID 方案</li><li>如何优化慢查询</li><li>explain 中每个字段的意思</li><li>explain 中的 type 字段有哪些常见的值</li><li>explain 中你通常关注哪些字段，为什么</li></ul><h6 id=jvm>JVM</h6><ul><li>运行时数据区</li><li>服务器使用的什么垃圾收集器</li><li>CMS 垃圾收集的原理</li><li>G1 垃圾收集的特点，为什么低延迟</li><li>有哪些垃圾回收算法，优缺点</li><li>哪些对象可以作为 GC Roots</li><li>有哪些类加载器</li><li>双亲委派模式，哪些场景是打破双亲委派模式</li><li>线上服务器出现频繁 Full GC，怎么排查</li><li>定位问题常用哪些命令</li><li>介绍下 JVM 调优的过程</li></ul><h6 id=kafka>Kafka</h6><ul><li>为什么使用 Kafka</li><li>介绍下 Kafka 的各个组件</li><li>如何保证写入 Kafka 的数据不丢失</li><li>如何保证从 Kafka 消费的数据不丢失</li><li>Kafka 为什么性能这么高</li><li>零拷贝技术使用哪个方法实现</li><li>Java 中也有类似的零拷贝技术，是哪个方法</li><li>Kafka 怎么保证消息的顺序消费</li><li>Kafka 怎么避免重复消费</li><li>什么是 HighWatermark 和 LEO</li><li>什么是 ISR，为什么需要引入 ISR</li></ul><h6 id=redis>Redis</h6><ul><li>项目中使用的 Redis 版本</li><li>Redis 在项目中的使用场景</li><li>Redis 怎么保证高可用</li><li>Redis 的选举流程</li><li>Redis 和 Memcache 的区别</li><li>Redis 的集群模式</li><li>Redis 集群要增加分片，槽的迁移怎么保证无损</li><li>Redis 分布式锁的实现</li><li>Redis 删除过期键的策略</li><li>Redis 的内存淘汰策略</li><li>Redis 的 Hash 对象底层结构</li><li>Redis 中 Hash 对象的扩容流程</li><li>Redis 的 Hash 对象的扩容流程在数据量大的时候会有什么问题吗</li><li>Redis 的持久化机制有哪几种</li><li>RDB 和 AOF 的实现原理、优缺点</li><li>AOF 重写的过程</li><li>哨兵模式的原理</li><li>使用缓存时，先操作数据库还是先操作缓存</li><li>为什么是让缓存失效，而不是更新缓存</li><li>缓存穿透、缓存击穿、缓存雪崩</li><li>更新缓存的几种设计模式</li></ul><h6 id=zookeeper>Zookeeper</h6><ul><li>Zookeeper 的使用场景</li><li>Zookeeper 怎么实现分布式锁</li><li>Zookeeper 怎么保证数据的一致性</li><li>ZAB 协议的原理</li><li>Zookeeper 遵循 CAP 中的哪些</li><li>Zookeeper 和 Eureka 的区别</li><li>Zookeeper 的 Leader 选举</li><li>Observer 的作用</li><li>Leader 发送了 commit 消息，但是所有的 follower 都没有收到这条消息，Leader 就挂了，后续会怎么处理</li></ul><h6 id=分布式>分布式</h6><ul><li>CAP 理论</li><li>BASE 理论</li><li>分布式事务 2PC 和 TCC 的原理</li><li>TCC 在 cancel 阶段如果出现失败怎么处理</li><li>Paxos 算法、Raft 算法</li></ul><h4 id=问题详解>问题详解</h4><p><strong>Java基础</strong></p><blockquote><p>String、StringBuffer、StringBuilder 有什么区别？</p></blockquote><p>String是不可变的类，它的拼接、裁剪字符串都会产生一个新的对象。StringBuffer是一个线程安全的可修改字符串的类。StringBuilder是Java1.5中新增的，它去掉了线程安全，性能上比StringBuffer更快。</p><blockquote><p>谈谈Java的反射机制，动态代理是基于什么原理？</p></blockquote><p>反射机制是Java提供的一种基础功能。通过反射，我们可以直接操作类或者对象，获取类的定义，属性，方法，调用方法或者构造对象，甚至可以运行时修改类定义。</p><p>动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制。</p><p>实现动态代理的方式有很多，JDK自身提供的动态代理，就是主要利用反射机制。还有字节码操作机制，cglib等。</p><h5 id=集合-1>集合</h5><blockquote><p>经常用到哪些 Map</p></blockquote><p>LinkedHashMap、ConcurrentHashMap、TreeMap、HashMap、hashTable</p><blockquote><p>这几种 Map 的区别</p></blockquote><p>ConcurrentHashMap是线程安全的</p><p>LinkedHashMap可以记录插入顺序和访问顺序</p><p>TreeMap可以自定义排序</p><p>除了这几个场景，其他场景都能使用HashMap</p><blockquote><p>ConcurrentHashMap 怎么保证线程安全</p></blockquote><p>JDK1.8之前是通过分段加锁，JDK1.8之后是通过CAS+Synchronize</p><p>分段锁：就是将内部进行分段（Segment），里面存放的也是跟HashMap类似的HashEntry数组，利用分段设计，在进行并发操作的时候，只需要锁定相应的段，这样就有效避免了整体同步的问题，大大提高了性能</p><blockquote><p>ConcurrentHashMap 在 JDK 1.8 前后的锁有什么区别</p></blockquote><p>JDK1.8以前使用Segment将内部进行分段，JDK1.8之后，Segment不再有任何结构上的用处，使用Synchronize同步代码块，数据存储利用volatile来保证可见性，使用CAS等操作，在特定场景进行无锁并发操作。</p><blockquote><p>聊下 HashMap 的原理</p></blockquote><p>HashMap内部是数组和链表组成的复合结构，数组被分为一个个桶，通过哈希值决定了键值对在这个数组的寻址；哈希值相同的键值对，则以链表形式存储，如果链表大小超过阈值(8)，会将链表转成红黑树存储。</p><blockquote><p>HashMap 在 Put 时，新链表节点是放在头部还是尾部</p></blockquote><p>JDK1.8以前是放在头部，JDK1.8之后是插入的链表尾部</p><blockquote><p>HashMap 扩容时的流程</p></blockquote><p>HashMap扩容发生在达到阈值时，阈值就是容量*负载因子</p><p>HashMap的默认初始容量大小16，HashMap的最大容量 ：2的30次方</p><p>当数组中数据的个数超过总数的0.75时，HashMap就会自动扩容，扩容到原数组容量的两倍。</p><p>jdk1.7扩容是重新计算hash；jdk1.8是要看看原来的hash值新增的那个bit是1还是0好了，如果是0则索引没变，如果是1则索引变成"原索引+oldCap"</p><blockquote><p>HashMap 在 JDK 1.8 有什么改变</p></blockquote><p>数据结构：1.7是数组+链表，1.8则是数组+链表+红黑树结构;</p><p>jdk1.7中当哈希表为空时，会先调用inflateTable()初始化一个数组；而1.8则是直接调用resize()扩容;</p><p>插入键值对的put方法的区别，1.8中会将节点插入到链表尾部，而1.7中是采用头插；</p><p>jdk1.7中的hash函数对哈希值的计算直接使用key的hashCode值，而1.8中则是采用key的hashCode异或上key的hashCode进行无符号右移16位的结果，避免了只靠低位数据来计算哈希时导致的冲突，计算结果由高低位结合决定，使元素分布更均匀；</p><p>扩容时1.8会保持原链表的顺序，而1.7会颠倒链表的顺序；而且<strong>1.8是在元素插入后检测是否需要扩容</strong>，1.7则是在元素插入前；</p><p>jdk1.7扩容是重新计算hash；jdk1.8是要看看原来的hash值新增的那个bit是1还是0好了，如果是0则索引没变，如果是1则索引变成"原索引+oldCap"</p><p>扩容：</p><blockquote><p>红黑树的优势和特点</p></blockquote><p>之所以选择红黑树是为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。</p><p>而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树。</p><p>红黑树的特点：</p><ul><li>每个节点非红即黑</li><li>根节点总是黑色的</li><li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）</li><li>每个叶子节点都是黑色的空节点（NIL节点）</li><li>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）</li></ul><blockquote><p>CocurrentHashMap 在 JDK 1.8 有什么改变</p></blockquote><p>JDK7:</p><p>数据结构：ReentrantLock+Segment+HashEntry，一个Segment中包含一个HashEntry数组，每个HashEntry又是一个链表结构</p><p>元素查询：二次hash，第一次Hash定位到Segment，第二次hash定位到元素所在的链表的头部</p><p>锁：Segment分段锁，Segment继承自ReentranLock，锁定操作的Segment，其他Segment不受影响，Segment个数可以通过构造函数指定，数组扩容不会影响其他的Segment</p><p>JDK8：</p><p>数据结构：synchronized+CAS+Node+红黑树，Node的val和next都用volatile修饰，保证可见性</p><p>查找、替换、赋值操作都使用CAS</p><p>锁：锁链表的head节点，不影响其他元素的读写，锁粒度更细，效率更高。</p><blockquote><p>TreeMap 的原理</p></blockquote><p>TreeMap是基于红黑树的一种提供顺序访问的Map,具体的顺序可以由指定的Comparator决定，或者根据键的自然顺序来判断</p><blockquote><p>List和set、map的区别是什么，他们分别使用在什么场合？</p></blockquote><p>List、Set是实现了Collection接口的子接口；而Map是另一个集合接口；</p><p>List：有序可重复，可以有多个null元素。<strong>用于有序访问、索引访问</strong></p><p>Set：无序不可重复，只允许一个null元素。<strong>可用于去重场景</strong></p><p>Map：map是一种键值对的存储方式，Map可能会持有相同的值对象，但键对象必须是唯一的。<strong>用于键值存储场景</strong>。</p><p>Map接口的实现类：HashMap、TreeMap、LinkedHashMap、HashTable</p><blockquote><p>ArrayList和LinkedList的区别</p></blockquote><p>ArrayList：基于动态数组，连续内存存储，适合下标访问(随机访问)，初始容量10</p><p>LinkedList：基于链表，可以存储在分散的内存中，适合做数据插入及删除操作，不适合查询，需要逐一遍历</p><blockquote><p>Map、List、Set 分别说下你知道的线程安全类和线程不安全的类</p></blockquote><p>Map：线程不安全类：HashMap、LinkedHashMap；线程安全类：HashTable、ConcurrentHashMap</p><p>List：线程不安全类：ArrayList、LinkedList；线程安全类：</p><p>Set：线程不安全类：HashSet、LinkedHashSet、TreeSet；线程安全类</p><h5 id=多线程>多线程</h5><blockquote><p>Java如何开启线程？怎么保证线程安全？</p></blockquote><p>Java开启线程的方式：1.继承Thread类，重写run方法；2.实现Runnable接口，实现run方法；3.实现Callable接口，实现call方法，通过FutrTask创建一个线程，获取到线程执行的返回值；4.使用线程池；</p><p>保证线程安全的方式：加锁。1.JVM提供的锁，也就是Synchronized关键字；2.JDK提供的各种Lock锁。</p><blockquote><p>Volatile和Synchronized有什么区别？Volatile能不能保证线程安全？</p></blockquote><p>1、Synchronized关键字用来加锁，保证并发的原子性，而Volatile保证变量的可见性以及防止指令重排。通常用于一个线程写，多个线程读的场景，</p><p>2、Volatile不能保证线程安全，它只解决了线程安全中的可见性和有序性的问题，关键的原子性问题并不能保证。</p><p>3、Volatile防止指令重排。在双重检查锁单例下，可以防止并发情况下，指令重排造成的线程安全问题。</p><blockquote><p>线程池使用的是哪种</p></blockquote><p>线程池通常都是利用Executors提供的通用线程池创建方法，去创建不同配置的线程池，主要区别在于不同的ExecutorService类型或者不同的初始参数，有5种不同的线程池创建配置</p><p>newCachedThreadPool()</p><p>newFixedThreadPool(int nThreads)</p><p>newSingleThreadExecutor()</p><p>newSingleThreadScheduledExecutor() 和 newScheduledThreadPool(int corePoolSize)</p><p>newWorkStealingPool(int parallelism)</p><blockquote><p>线程池参数怎么配置</p></blockquote><p>corePoolSize: 核心线程数大小</p><p>maximumPoolSize: 最大线程数</p><p>keepAliveTime: 存活时间</p><p>unit: keepAliveTime的时间单位</p><p>workQuene: 存放待执行任务的队列</p><p>threadFactory: 线程工厂</p><p>handler: 拒绝策略</p><p>一般先区分你的任务CPU密集型还是IO密集型，CPU密集型任务配置尽可能少的线程数量，一般公式：CPU核数 + 1 线程的线程池；IO密集型：大部分的线程都阻塞，故需要多配置线程数</p><blockquote><p>线程池各个参数的作用</p></blockquote><p>1.<em>corePoolSize</em>：</p><p>（核心线程数大小：不管它们创建以后是不是空闲的。线程池需要保持 corePoolSize 数量的线程，除非设置了 allowCoreThreadTimeOut。）</p><p>2.<em>maximumPoolSize</em>：</p><p>（最大线程数：线程池中最多允许创建 maximumPoolSize 个线程。）</p><p>3.<em>keepAliveTime</em>：</p><p>（存活时间：如果经过 keepAliveTime 时间后，超过核心线程数的线程还没有接受到新的任务，那就回收。）</p><p>4.<em>unit</em>：</p><p>（keepAliveTime 的时间单位。）</p><p>5.<em>workQueue</em>：</p><p>（存放待执行任务的队列：当提交的任务数超过核心线程数大小后，再提交的任务就存放在这里。它仅仅用来存放被 execute 方法提交的 Runnable 任务。）</p><p>6.<em>threadFactory</em>：</p><p>（线程工厂：用来创建线程工厂。比如这里面可以自定义线程名称，当进行虚拟机栈分析时，看着名字就知道这个线程是哪里来的，不会懵逼。）</p><p>7.<em>handler</em> ：</p><p>（拒绝策略：当队列里面放满了任务、最大线程数的线程都在工作时，这时继续提交的任务线程池就处理不了，应该执行怎么样的拒绝策略。）</p><blockquote><p><strong>线程池的参数配置要注意什么</strong></p></blockquote><p>主要注意的是这几个参数：<strong>corePoolSize、maximumPoolSize、workQueue（队列长度）</strong></p><blockquote><p>线程池的工作流程</p></blockquote><p>提交任务，判断线程池是否在运行，如果还在运行，就判断线程数是否小于核心数，否则拒绝任务，如果线程数小于核心数，就添加工作线程并执行，如果线程数超过了核心线程数，就判断阻塞队列是否已满，如果没有满，就添加阻塞队列等待工作线程获取执行，如果阻塞队列已满，就判断线程数是否小于最大线程数，如果小于，就添加工作线程并执行，如果不小于，就拒绝任务</p><blockquote><p>JDK 中的并发类知道哪些</p></blockquote><p>提供了比 synchronized 更加高级的各种同步结构，包括 CountDownLatch、CyclicBarrier、Semaphore 等，可以实现更加丰富的多线程操作，比如利用 Semaphore 作为资源控制器，限制同时进行工作的线程数量。</p><p>各种线程安全的容器，比如最常见的 ConcurrentHashMap、有序的 ConcurrentSkipListMap，或者通过类似快照机制，实现线程安全的动态数组 CopyOnWriteArrayList 等。</p><p>各种并发队列实现，如各种 BlockingQueue 实现，比较典型的 ArrayBlockingQueue、 SynchronousQueue 或针对特定场景的 PriorityBlockingQueue 等。</p><p>强大的 Executor 框架，可以创建各种不同类型的线程池，调度任务运行等，绝大部分情况下，不再需要自己从头实现线程池和任务调度器。</p><blockquote><p>AQS 的底层原理</p></blockquote><p>AQS, AbstractQueuedSynchronizer,它是实现各种同步结构和部分其他组成单元（如线程池中的 Worker）的基础。</p><blockquote><p>介绍下悲观锁和乐观锁</p></blockquote><p>悲观锁和乐观锁是两种思想，用于解决高并发场景下的数据竞争问题。</p><ul><li>乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在更新期间判断下在此期间别人是否修改了数据，如果别人修改了数据则放弃操作，否则执行操作；典型应用：CAS，版本机制。</li><li>悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作时直接把数据锁住，直到操作完成才会释放锁，上锁期间其他人不能修改数据。</li></ul><blockquote><p>使用过哪些锁</p></blockquote><blockquote><p>synchronized 和 Lock 的区别、使用场景</p></blockquote><blockquote><p>synchronized底层是如何实现的？什么是锁的升级、降级？</p></blockquote><p>synchronized底层是使用monitorenter/monitorexit指令实现的，Monitor对象是同步的基本实现单元。现代的JDK中，JVM对此进行了大刀阔斧地改进，提供了三种不同的Monitor实现，也就是常说的三种不同的锁：偏斜锁、轻量级锁、重量级锁，大大改进了其性能。</p><p>所谓锁的升级、降级，就是 JVM 优化 synchronized 运行的机制，当 JVM 检测到不同的竞争状况时，会自动切换到适合的锁实现，这种切换就是锁的升级、降级。</p><p>当没有竞争出现时，默认会使用偏斜锁。JVM 会利用 CAS 操作，在对象头的Mark Word部分设置线程ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。</p><blockquote><p>synchronized 作用于静态方法、普通方法、this、Lock.class 的区别</p></blockquote><blockquote><p>为什么引入偏向锁、轻量级锁，介绍下升级流程</p></blockquote><p>偏向锁：JVM会利用CAS操作，在对象头的Mark Word部分设置线程ID，以表示这个对象偏向于当前线程，</p><blockquote><p>死锁的必要条件，如何预防死锁</p></blockquote><blockquote><p>介绍下 CountDownLatch 和 CyclicBarrier</p></blockquote><blockquote><p>介绍下 CAS，存在什么问题</p></blockquote><p>CAS就是比较和交换，用于多线程实现同步的原子指令。它将内存中的值与当前值进行比较，只有它们相同时，才将内存中的值修改为新的值。否则，要么进行重试，要么就返回一个成功或者失败的结果。</p><p>CAS存在的问题，一个是它的失败重试机制，隐含着一个假设，即竞争情况是短暂的。大多数应用场景中，确实大部分重试只会发生一次就获得了成功，但是总是有意外情况，所以在有需要的时候，还是要考虑限制自旋的次数，以免过度消耗 CPU。另外一个就是著名的ABA问题，这是通常只在 lock-free 算法下暴露的问题。CAS 是在更新时比较前值，如果对方只是恰好相同，例如期间发生了 A -> B -> A 的更新，仅仅判断数值是 A，可能导致不合理的修改操作。针对这种情况，Java 提供了 AtomicStampedReference 工具类，通过为引用建立类似版本号（stamp）的方式，来保证 CAS 的正确性。</p><blockquote><p>介绍下 ThreadLocal，存在什么问题</p></blockquote><h5 id=jvm-1>JVM</h5><blockquote><p>运行时数据区</p></blockquote><blockquote><p>服务器使用的什么垃圾收集器</p></blockquote><blockquote><p>CMS 垃圾收集的原理</p></blockquote><blockquote><p>G1 垃圾收集的特点，为什么低延迟</p></blockquote><blockquote><p>有哪些垃圾回收算法，优缺点</p></blockquote><blockquote><p>哪些对象可以作为 GC Roots</p></blockquote><blockquote><p>有哪些类加载器</p></blockquote><blockquote><p>双亲委派模式，哪些场景是打破双亲委派模式</p></blockquote><blockquote><p>线上服务器出现频繁 Full GC，怎么排查</p></blockquote><ol><li>查看监控，以了解出现问题的时间点以及当前FGC的频率（可对比正常情况看频率是否正常）</li><li>了解该时间点之前有没有程序上线、基础组件升级等情况。</li><li>了解JVM的参数设置，包括：堆空间各个区域的大小设置，新生代和老年代分别采用了哪些垃圾收集器，然后分析JVM参数设置是否合理。</li><li>再对步骤1中列出的可能原因做排除法，其中元空间被打满、内存泄漏、代码显式调用gc方法比较容易排查。</li><li>针对大对象或者长生命周期对象导致的FGC，可通过 jmap -histo 命令并结合dump堆内存文件作进一步分析，需要先定位到可疑对象。</li><li>通过可疑对象定位到具体代码再次分析，这时候要结合GC原理和JVM参数设置，弄清楚可疑对象是否满足了进入到老年代的条件才能下结论。</li></ol><blockquote><p>定位问题常用哪些命令</p></blockquote><blockquote><p>介绍下 JVM 调优的过程</p></blockquote><p>JVM调优的思路主要是观察内存和内存泄漏检查，观察内存释放情况，对象使用情况，堆空间分配大小，垃圾回收情况等，通过这些信息，我们就能解决堆内存设置是否合理，垃圾回收中年轻代与老年代中空间划分是否合理，这一步我们可以使用到的工具有jmp可以查看对象占用内存，jmp heap 命令显示java堆的详细情况，还可以通过jmap dump 来转储堆文件，然后还有jstack java堆栈跟踪工具，可以定位线程出现长时间停顿的问题，比如线程死锁、线程请求外部资源超时等，还有jstat查看jvm的统计信息，它一般常用于线上定位jvm性能，然后还有一些可视化工具，包括Jconsole啊，VisualVM，jProfilter等，通过这些工具，我们就可以来识别JVM性能问题，然后通过调整JVM的参数来进行调优以及内存溢出问题检查，通过堆转储文件进行分析，确认内存中对象是否存在问题，是否是资源未释放等。</p><h5 id=设计模式>设计模式</h5><h5 id=spring>Spring</h5><blockquote><p>介绍下 Spring IoC 的流程</p></blockquote><p>主要初始化Spring IoC容器，包括BeanDefinition的Resource定位、载入、注册三个基本过程。</p><p>BeanDefinition的资源定位过程就是找到定义的javabean信息，并将其封装成Resource对象</p><p>BeanDefinition的载入和解析就是把用户定义好的Javabean表示为IoC容器内部的数据结构，这个容器内部的数据结构就是BeanDefinition</p><p>BeanDefinition在IoC容器中的注册就是向IoC容器注册这些BeanDefinition，完成了BeanDefinition的注册，就完成了IoC容器的初始化过程。此时，在使用的IoC容器DefaultListableBeanFactory中已经建立了整个Bean的配置信息，而且这些BeanDefinition已经可以被容器使用了。容器的作用就是对这些信息进行处理和维护，这些信息是容器建立依赖反转的基础。</p><blockquote><p>BeanFactory 和 FactoryBean 的区别</p></blockquote><p>BeanFactory定义了IOC容器的最基本形式，并提供了IOC容器应遵守的的最基本的接口，也就是Spring IOC所遵守的最底层和最基本的编程规范。在Spring代码中，BeanFactory只是个接口，并不是IOC容器的具体实现。</p><p>一般情况下，Spring通过反射机制利用bean的class属性指定实现类实例化Bean，在某些情况下，实例化Bean过程比较复杂，如果按照传统的方式，则需要在中提供大量的配置信息。配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。Spring为此提供了一个FactoryBean的工厂类接口，用户可以通过实现该接口定制实例化Bean的逻辑。
BeanFactory是个Factory，也就是IOC容器或对象工厂，FactoryBean是个Bean，但它是一个能生产或者修饰对象生成的工厂bean。</p><blockquote><p>Spring 的 AOP 是怎么实现的</p></blockquote><p>Spring AOP 使用的是动态代理，所谓的动态代理就是说 AOP 框架不会去修改字节码，而是在内存中临时为方法生成一个 AOP 对象，这个 AOP 对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法 。</p><p>Spring AOP 中的动态代理主要有两种方式， JDK 动态代理和 CGLIB 动态代理 。</p><p>* JDK 动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口 。JDK 动态代理的核心是 InvocationHandler 接口和 Proxy 类 。</p><p>* 如果目标类没有实现接口，那么 Spring AOP 会选择使用 CGLIB 来动态代理目标类 。CGLIB （ Code Generation Library ），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意， CGLIB 是通过继承的方式做的动态代理，因此如果某个类被标记为 final ，那么它是无法使用 CGLIB 做动态代理的 。</p><blockquote><p>Spring bean的生命周期</p></blockquote><p>Bean的生命周期分为四个阶段：</p><p>实例化</p><p>属性赋值</p><p>初始化</p><p>销毁</p><p>但有非常多的扩展点用于Bean的生命周期，主要可以分为两类扩展点，一类是作用于多个Bean的，分为InstantiationAwareBeanPostProcessor和BeanPostProcessor, InstantiationAwareBeanPostProcessor作用于实例化前后，BeanPostProcessor作用于初始化前后，一类是影响单个Bean的只调用一次的接口，主要是Aware接口</p><blockquote><p>Spring 的事务传播行为有哪些，讲下嵌套事务</p></blockquote><blockquote><p>什么情况下对象不能被代理</p></blockquote><blockquote><p>Spring 怎么解决循环依赖的问题</p></blockquote><p>在Spring中，对象的实例化是通过反射实现的，而对象的属性则是在对象实例化之后通过一定的方式设置的。Spring为了解决单例的循环依赖问题，使用了三级缓存。</p><p>这三级缓存分别指：</p><ul><li>singletonFactories ：单例对象工厂的cache</li><li>earlySingletonObjects ：提前暴光的单例对象的Cache</li><li>singletonObjects：单例对象的cache</li></ul><p>在创建bean的时候，首先想到的是从cache中获取这个单例的bean，这个缓存就是singletonObjects。如果获取不到，并且对象正在创建中，就再从二级缓存earlySingletonObjects中获取。如果还是获取不到且允许singletonFactories通过getObject()获取，就从三级缓存singletonFactory.getObject()(三级缓存)获取，如果获取到了则：从singletonFactories中移除，并放入earlySingletonObjects中。其实也就是从三级缓存移动到了二级缓存。</p><blockquote><p>要在 Spring IoC 容器构建完毕之后执行一些逻辑，怎么实现</p></blockquote><blockquote><p>@Resource 和 @Autowire 的区别</p></blockquote><blockquote><p>@Autowire 怎么使用名称来注入</p></blockquote><blockquote><p>bean 的 init-method 属性指定的方法里用到了其他 bean 实例，会有问题吗</p></blockquote><blockquote><p>@PostConstruct 修饰的方法里用到了其他 bean 实例，会有问题吗</p></blockquote><blockquote><p>Spring 中，有两个 id 相同的 bean，会报错吗，如果会报错，在哪个阶段报错</p></blockquote><blockquote><p>Spring 中，bean 的 class 属性指定了一个不存在的 class，会报错吗，如果会报错，在哪个阶段</p></blockquote><blockquote><p>Spring 中的常见扩展点有哪些</p></blockquote><h5 id=springboot>SpringBoot</h5><h5 id=springcloud>SpringCloud</h5><h5 id=mysql-1>Mysql</h5><blockquote><p>Mysql优化策略</p></blockquote><ul><li>设计数据库时：数据库表、字段的设计，存储引擎</li><li>利用好MySQL自身提供的功能，如索引等</li><li>横向扩展：MySQL集群、负载均衡、读写分离</li><li>SQL语句的优化（收效甚微）</li></ul><blockquote><p>MySQL 索引的数据结构</p></blockquote><p>mysql索引的数据结构是树，常用的存储引擎innodb采用的是B+Tree</p><blockquote><p>为什么使用 B+ 树，与其他索引相比有什么优点</p></blockquote><p>B+树是B树的变体，相对于B树，叶子结点的值包含了所有的值，所有父结点的值是重复了叶子结点的值，</p><p>父结点只起索引查找的作用，同时所叶子结点也也构成了一条有序的链表。</p><p>B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少，从而导致树的高度增加，IO操作变多，查询性能变低，而B+树的高度一般只有1-3</p><blockquote><p>各种索引之间的区别</p></blockquote><p>主键索引: mysql会为每个表的主键自动添加索引，在其索引树的叶子节点中，保存着主键所在行的所有数据</p><p>唯一索引: 其数据不可重复,不同的是其索引树的叶子节点保存的不是所在行的所有数据，而是该列的值</p><p>普通索引: 其值可以重复，而且索引树叶子节点保存的就是该列的值，而不是整行数据</p><p>聚合索引: 因为每个索引对应一棵索引树</p><blockquote><p>B+ 树在进行范围查找时怎么处理</p></blockquote><p>找到起始叶子节点，包括范围起始值，沿着叶的链接读下一个节点，直到遇到范围终止值</p><blockquote><p>MySQL 索引叶子节点存放的是什么</p></blockquote><p>B+树结构的索引，主键索引的叶子节点保存了该行的所有数据，普通索引存放的是主键的值</p><blockquote><p>索引的查询过程</p></blockquote><p>如果是主键索引，通过索引查询到叶子节点，主键索引的叶子节点保存了该行的所有数据，直接返回就可以了；如果是普通索引，通过索引查询到叶子节点后，由于普通索引的叶子节点保存的是主键的值，还要根据主键的值去主键索引中查询数据，这个查询过程就称之为回表。</p><blockquote><p>联合索引（复合索引）的底层实现</p></blockquote><p>联合索引也是一棵B+树，索引值保存了多个列的值，键值也是排序的，但它是按最左原则排的序。</p><blockquote><p>MySQL 如何锁住一行数据</p></blockquote><p>在SQL语句后面加上for update.</p><blockquote><p>SELECT 语句能加互斥锁吗</p></blockquote><blockquote><p>多个事务同时对一行数据进行 SELECT FOR UPDATE 会阻塞还是异常</p></blockquote><blockquote><p>MySQL 使用的版本和执行引擎</p></blockquote><blockquote><p>MySQL 不同执行引擎的区别</p></blockquote><blockquote><p>MySQL 的事务隔离级别</p></blockquote><blockquote><p>MySQL 的可重复读是怎么实现的</p></blockquote><blockquote><p>MySQL 是否会出现幻读</p></blockquote><blockquote><p>MySQL 的 gap 锁</p></blockquote><blockquote><p>MySQL 的主从同步原理</p></blockquote><blockquote><p>分库分表的实现方案</p></blockquote><p>使用hash进行路由策略</p><blockquote><p>分布式唯一 ID 方案</p></blockquote><blockquote><p>如何优化慢查询</p></blockquote><blockquote><p>explain 中每个字段的意思</p></blockquote><blockquote><p>explain 中的 type 字段有哪些常见的值</p></blockquote><blockquote><p>explain 中你通常关注哪些字段，为什么</p></blockquote><h5 id=mybatis>MyBatis</h5><blockquote><p>Mybatis缓存</p></blockquote><h5 id=redis-1>Redis</h5><h5 id=zookeeper-1>Zookeeper</h5><h5 id=dubbo>Dubbo</h5><blockquote><p>Dubbo是什么</p></blockquote><p>Dubbo是阿里巴巴开源的基于 Java 的高性能 RPC 分布式服务框架，现已成为 Apache 基金会孵化项目。</p><h5 id=消息队列>消息队列</h5><h5 id=分布式-1>分布式</h5><blockquote><p>秒杀系统的设计</p></blockquote><p>秒杀系统的关键就是要做到高性能、一致性和高可用。</p><p>为实现高性能，我们可以通过从设计数据的动静分离方案、热点数据的发现与隔离、请求的削峰与分层过滤等方面考虑。</p><p>一致性主要体现在秒杀商品减库存的实现。</p><p>高可用方面我们可以设计一个兜底方案来应对。</p><p>然后就是具体的一些实现方案上面，首先，数据的动静分离，主要说的是商品信息数据，通过将商品信息数据展示页面通过动静分离，将一些静态数据缓存到离用户近的地方，比如浏览器，CDN上或者服务端的缓存中。</p><p>热点数据的处理主要就是优化、限制与隔离，优化就是将热点数据缓存起来以提升访问性能，限制更多的是一种保护机制，将访问热点数据的请求限制在一个请求队列中，防止因某些热点商品占用太多服务器资源，而使其他请求始终得不到服务器的处理资源。隔离就是热点数据隔离出来，比如使用专门的数据库，防止这1%的热点数据请求影响到其他的99%的请求。</p><p>然后就是流量削峰，可以通过排队、答题、分层过滤等方案来实现，排队就是通过消息队列将同步的直接调用转换成异步的间接推送，通过消息队列来缓冲瞬时流量，答题就是通过增加限制手段来防止一些作弊，还有就是延缓请求，分层过滤就是通过增加一些校验条件来将一些无效的请求过滤掉，保证真正落到底层数据库中是有效请求。</p><p>高性能方面差不多这些就应该可以保证系统的一个并发量，然后就是秒杀商品减库存的一致性实现，主要就是保证大量并发请求时库存数据不能为负数，我们可以通过使用事务来保证减后库存不能为负数，或者直接设置数据中的库存字段为无符号整数。而扣减库存的方案我们使用下单就扣减库存，通过先查询库存数量是否正确，如果库存已经为0了，直接就返回结果了。</p><p>最后就是高可用的兜底方案，可以通过降级、限流、拒绝服务来做最后的保护，防止最坏情况下因把服务器压垮而长时间彻底无法提供服务。</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2021-04-13</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/java%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0/ class=prev rel=prev title=Java并发学习><i class="fas fa-angle-left fa-fw"></i>Java并发学习</a>
<a href=/posts/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/ class=next rel=next title=网络通信>网络通信<i class="fas fa-angle-right fa-fw"></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.81.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i>LoveIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2021</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank></a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i></a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>