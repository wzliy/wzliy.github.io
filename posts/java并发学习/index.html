<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>Java并发学习 - arvin's blog</title><meta name=Description content><meta property="og:title" content="Java并发学习"><meta property="og:description" content="软件并发已经成为现代软件开发的基础能力，而Java精心设计的高效并发机制，正是构建大规模应用的基础之一。
并发可以充分发挥多处理器系统的强大计算能力，随着处理器数量的持续增长，如何高效地使用并发正变得越来越重要。
进程与线程 进程 进程使程序的一次执行过程，是系统运行的基本单位，系统运行一个程序的过程即是一个进程从创建、运行到消亡的过程。
早期的计算机中不包含操作系统，它们从头到尾只执行一个程序，并且这个程序能够访问计算机中所有的资源。操作系统的出现使得计算机每次能运行多个程序，并且不同的程序都在单独的进程中运行：操作系统为每个独立执行的进程分配各种资源，包括内存，文件句柄以及安全证书等。如果需要的话，在不同的进程中可以通过一些粗粒度的通信机制来交换数据，包括：套接字、信号处理器、共享内存、信号量以及文件等。
之所以在计算机中加入操作系统来实现多个程序的同时执行，主要基于以下原因：
 资源利用率：在某些情况下，程序必须等待某个外部操作执行完成，例如输入输出操作，因此，如果在等待的同时可以运行另一个程序，那么无疑将提高资源利用率。 公平性：不同的用户和程序对于计算机上的资源有着同等的使用权。一种高效的运行的方式时通过粗粒度的时间分片，使这些用户和程序能共享计算机资源。 便利性：通常来说，在计算多个任务时，应该编写多个程序，每个程序执行一个任务并在必要时相互通信，这比只编写一个程序来计算所有任务更容易实现。  线程 线程是比进程更小的执行单位。线程允许在同一个进程中存在多个程序控制流。线程会共享进程范围内的资源，例如内存句柄和文件句柄，但每个线程都有自己的程序计数器、栈以及局部变量等。
线程也被称为轻量级进程。在大多数现代操作系统中，都是以线程为基本的调度单位，而不是进程。如果没有明确的协调机制，那么线程将彼此独立运行。由于同一个进程中所有线程都将共享进程内的内存地址空间，因此这些线程都能访问相同的变量并在同一个堆上分配对象，这就需要实现一种比在进程间共享数据粒度更细的数据共享机制。如果没有明确的同步机制来协同对共享数据的访问，那么当一个线程正在使用某个变量时，另一个线程可能同时访问这个变量，这将造成不可预测的结果。
Java程序天生就是多线程程序：一个Java程序的运行时main线程和多个其他线程同时运行。
线程的优势 线程可以有效降低程序的开发和维护成本，同时提升复杂应用程序的性能。线程能够将大部分的异步工作流转换成串行工作流，因此能更好地模拟人类的工作方式和交互方式。
在GUI应用程序中，线程可以提高用户界面的响应灵敏度，而在服务器应用程序中，可以提升资源利用率以及系统吞吐率。线程还可以简化JVM的实现，垃圾收集器通常在一个或多个专门的线程中运行。在许多重要的Java应用程序中，都在一定程度上用到了线程。
线程带来的风险  安全性问题 活跃性问题 性能问题  线程安全性 并发的核心在于线程安全，什么是线程安全？
 线程安全是一个多线程环境下正确性的概念，也就是保证多线程环境下共享的、可修改的状态的正确性。
《Java并发编程实战》
 这里的状态可以反映在程序中其实可以看作是数据。换个角度来看，如果状态不是共享的，或者不是可修改的，也就不存在线程安全问题，所以，进而可以推理出保证线程安全的两个办法：封装(将对象内部状态隐藏保护起来，变得不可共享)，不可变（通过final或者immutable使状态不可变）。
线程安全需要保证几个基本特性：
 原子性：简单来说就是相关操作不会中途被其他线程干扰，一般可通过同步机制实现。 可见性：一个线程修改了某个共享变量，其他线程可以同步获取修改结果，通常被解释为将线程本地状态反映到主内存上，volatile就是负责保证可见性的。 有序性：保证线程内串行语义，避免指令重排等。  解决原子性问题
原子性问题的源头是线程切换，如果能够禁用线程切换就能从源头解决这个问题，而操作系统做线程切换是依赖cpu中断的，所以禁止CPU发生中断就能够禁止线程切换。在早期的单核CPU时代，这个方案是可行的，但在多核场景下，同一时刻，有可能有两个线程同时执行，此时禁止CPU中断，只能保证CPU上的线程连续执行，并不能保证同一时刻只有一个线程执行。
同一个时刻只有一个线程执行，我们称之为互斥，如果能够保证对共享变量的修改是互斥的，那么，就能够保证原子性了。
互斥锁就是用来解决原子性问题的
锁 受保护资源和锁之间合理的关联关系应该是N:1的关系，也就是说可以用一把锁来保护多个资源，但是不能用多把锁来保护一个资源。
用不同的锁对受保护资源进行精细化管理，能够提升性能。这种锁称为细粒度锁。
synchronized与ReentrantLock synchronized是Java内建的同步机制，它提供了互斥的语义和可见性，当一个线程已经获取当前锁时，其他试图获取的线程只能等待或者阻塞在那里。
ReentrantLock，通常翻译为再入锁，使Java5提供的锁实现。
synchronized
Java编译器会在synchronized修饰的方法或代码块前后自动加上加锁lock()和解锁uncheck()。
如何用一把锁保护多个资源  受保护的资源和锁之间的合理的关联关系应该是N:1的关系
 一把锁可以保护多个资源，但不能用多个锁来保护一个资源。
我们可以用一把锁来保护多个资源，但会导致性能太差。用不同的锁对受保护的资源进行精细化管理，能够提升性能，这种锁被叫做细粒度锁。
保护有关联关系的多个资源 如果多个资源是有关联关系的，那么这个问题就比较复杂了。
比如一个银行转账问题，A账户给B账户转账100元，在Account类中有一个transfer()的用于转账的方法。
class Account { private int balance; // 转账  void transfer( Account target, int amt){ if (this."><meta property="og:type" content="article"><meta property="og:url" content="https://wzliy.github.io/posts/java%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-03-30T21:39:35+08:00"><meta property="article:modified_time" content="2021-03-30T21:39:35+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java并发学习"><meta name=twitter:description content="软件并发已经成为现代软件开发的基础能力，而Java精心设计的高效并发机制，正是构建大规模应用的基础之一。
并发可以充分发挥多处理器系统的强大计算能力，随着处理器数量的持续增长，如何高效地使用并发正变得越来越重要。
进程与线程 进程 进程使程序的一次执行过程，是系统运行的基本单位，系统运行一个程序的过程即是一个进程从创建、运行到消亡的过程。
早期的计算机中不包含操作系统，它们从头到尾只执行一个程序，并且这个程序能够访问计算机中所有的资源。操作系统的出现使得计算机每次能运行多个程序，并且不同的程序都在单独的进程中运行：操作系统为每个独立执行的进程分配各种资源，包括内存，文件句柄以及安全证书等。如果需要的话，在不同的进程中可以通过一些粗粒度的通信机制来交换数据，包括：套接字、信号处理器、共享内存、信号量以及文件等。
之所以在计算机中加入操作系统来实现多个程序的同时执行，主要基于以下原因：
 资源利用率：在某些情况下，程序必须等待某个外部操作执行完成，例如输入输出操作，因此，如果在等待的同时可以运行另一个程序，那么无疑将提高资源利用率。 公平性：不同的用户和程序对于计算机上的资源有着同等的使用权。一种高效的运行的方式时通过粗粒度的时间分片，使这些用户和程序能共享计算机资源。 便利性：通常来说，在计算多个任务时，应该编写多个程序，每个程序执行一个任务并在必要时相互通信，这比只编写一个程序来计算所有任务更容易实现。  线程 线程是比进程更小的执行单位。线程允许在同一个进程中存在多个程序控制流。线程会共享进程范围内的资源，例如内存句柄和文件句柄，但每个线程都有自己的程序计数器、栈以及局部变量等。
线程也被称为轻量级进程。在大多数现代操作系统中，都是以线程为基本的调度单位，而不是进程。如果没有明确的协调机制，那么线程将彼此独立运行。由于同一个进程中所有线程都将共享进程内的内存地址空间，因此这些线程都能访问相同的变量并在同一个堆上分配对象，这就需要实现一种比在进程间共享数据粒度更细的数据共享机制。如果没有明确的同步机制来协同对共享数据的访问，那么当一个线程正在使用某个变量时，另一个线程可能同时访问这个变量，这将造成不可预测的结果。
Java程序天生就是多线程程序：一个Java程序的运行时main线程和多个其他线程同时运行。
线程的优势 线程可以有效降低程序的开发和维护成本，同时提升复杂应用程序的性能。线程能够将大部分的异步工作流转换成串行工作流，因此能更好地模拟人类的工作方式和交互方式。
在GUI应用程序中，线程可以提高用户界面的响应灵敏度，而在服务器应用程序中，可以提升资源利用率以及系统吞吐率。线程还可以简化JVM的实现，垃圾收集器通常在一个或多个专门的线程中运行。在许多重要的Java应用程序中，都在一定程度上用到了线程。
线程带来的风险  安全性问题 活跃性问题 性能问题  线程安全性 并发的核心在于线程安全，什么是线程安全？
 线程安全是一个多线程环境下正确性的概念，也就是保证多线程环境下共享的、可修改的状态的正确性。
《Java并发编程实战》
 这里的状态可以反映在程序中其实可以看作是数据。换个角度来看，如果状态不是共享的，或者不是可修改的，也就不存在线程安全问题，所以，进而可以推理出保证线程安全的两个办法：封装(将对象内部状态隐藏保护起来，变得不可共享)，不可变（通过final或者immutable使状态不可变）。
线程安全需要保证几个基本特性：
 原子性：简单来说就是相关操作不会中途被其他线程干扰，一般可通过同步机制实现。 可见性：一个线程修改了某个共享变量，其他线程可以同步获取修改结果，通常被解释为将线程本地状态反映到主内存上，volatile就是负责保证可见性的。 有序性：保证线程内串行语义，避免指令重排等。  解决原子性问题
原子性问题的源头是线程切换，如果能够禁用线程切换就能从源头解决这个问题，而操作系统做线程切换是依赖cpu中断的，所以禁止CPU发生中断就能够禁止线程切换。在早期的单核CPU时代，这个方案是可行的，但在多核场景下，同一时刻，有可能有两个线程同时执行，此时禁止CPU中断，只能保证CPU上的线程连续执行，并不能保证同一时刻只有一个线程执行。
同一个时刻只有一个线程执行，我们称之为互斥，如果能够保证对共享变量的修改是互斥的，那么，就能够保证原子性了。
互斥锁就是用来解决原子性问题的
锁 受保护资源和锁之间合理的关联关系应该是N:1的关系，也就是说可以用一把锁来保护多个资源，但是不能用多把锁来保护一个资源。
用不同的锁对受保护资源进行精细化管理，能够提升性能。这种锁称为细粒度锁。
synchronized与ReentrantLock synchronized是Java内建的同步机制，它提供了互斥的语义和可见性，当一个线程已经获取当前锁时，其他试图获取的线程只能等待或者阻塞在那里。
ReentrantLock，通常翻译为再入锁，使Java5提供的锁实现。
synchronized
Java编译器会在synchronized修饰的方法或代码块前后自动加上加锁lock()和解锁uncheck()。
如何用一把锁保护多个资源  受保护的资源和锁之间的合理的关联关系应该是N:1的关系
 一把锁可以保护多个资源，但不能用多个锁来保护一个资源。
我们可以用一把锁来保护多个资源，但会导致性能太差。用不同的锁对受保护的资源进行精细化管理，能够提升性能，这种锁被叫做细粒度锁。
保护有关联关系的多个资源 如果多个资源是有关联关系的，那么这个问题就比较复杂了。
比如一个银行转账问题，A账户给B账户转账100元，在Account类中有一个transfer()的用于转账的方法。
class Account { private int balance; // 转账  void transfer( Account target, int amt){ if (this."><meta name=application-name content="arvin's blog"><meta name=apple-mobile-web-app-title content="arvin's blog"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://wzliy.github.io/posts/java%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0/><link rel=prev href=https://wzliy.github.io/posts/java%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1/><link rel=next href=https://wzliy.github.io/posts/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Java并发学习","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/wzliy.github.io\/posts\/java%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0\/"},"genre":"posts","wordcount":299,"url":"https:\/\/wzliy.github.io\/posts\/java%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0\/","datePublished":"2021-03-30T21:39:35+08:00","dateModified":"2021-03-30T21:39:35+08:00","publisher":{"@type":"Organization","name":"arvin"},"author":{"@type":"Person","name":"arvin"},"description":""}</script></head><body header-desktop header-mobile><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':''==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:''==='dark')&&document.body.setAttribute('theme','dark')</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="arvin's blog">arvin's blog</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="arvin's blog">arvin's blog</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">Java并发学习</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>arvin</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2021-03-30>2021-03-30</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 299 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 2 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><ul><li><a href=#进程与线程>进程与线程</a></li><li><a href=#线程安全性>线程安全性</a></li></ul></li></ul></nav></div></div><div class=content id=content><p>软件并发已经成为现代软件开发的基础能力，而Java精心设计的高效并发机制，正是构建大规模应用的基础之一。</p><p>并发可以充分发挥多处理器系统的强大计算能力，随着处理器数量的持续增长，如何高效地使用并发正变得越来越重要。</p><h3 id=进程与线程>进程与线程</h3><h4 id=进程>进程</h4><p><strong>进程</strong>使程序的一次执行过程，是系统运行的基本单位，系统运行一个程序的过程即是一个进程从创建、运行到消亡的过程。</p><p>早期的计算机中不包含操作系统，它们从头到尾只执行一个程序，并且这个程序能够访问计算机中所有的资源。操作系统的出现使得计算机每次能运行多个程序，并且不同的程序都在单独的进程中运行：操作系统为每个独立执行的进程分配各种资源，包括内存，文件句柄以及安全证书等。如果需要的话，在不同的进程中可以通过一些粗粒度的通信机制来交换数据，包括：套接字、信号处理器、共享内存、信号量以及文件等。</p><p>之所以在计算机中加入操作系统来实现多个程序的同时执行，主要基于以下原因：</p><ul><li>资源利用率：在某些情况下，程序必须等待某个外部操作执行完成，例如输入输出操作，因此，如果在等待的同时可以运行另一个程序，那么无疑将提高资源利用率。</li><li>公平性：不同的用户和程序对于计算机上的资源有着同等的使用权。一种高效的运行的方式时通过粗粒度的时间分片，使这些用户和程序能共享计算机资源。</li><li>便利性：通常来说，在计算多个任务时，应该编写多个程序，每个程序执行一个任务并在必要时相互通信，这比只编写一个程序来计算所有任务更容易实现。</li></ul><h4 id=线程>线程</h4><p><strong>线程</strong>是比进程更小的执行单位。线程允许在同一个进程中存在多个程序控制流。线程会共享进程范围内的资源，例如<strong>内存句柄</strong>和<strong>文件句柄</strong>，但每个线程都有自己的<strong>程序计数器</strong>、<strong>栈</strong>以及<strong>局部变量</strong>等。</p><p>线程也被称为<strong>轻量级进程</strong>。在大多数现代操作系统中，都是以线程为基本的调度单位，而不是进程。如果没有明确的协调机制，那么线程将彼此独立运行。由于同一个进程中所有线程都将共享进程内的<strong>内存地址空间</strong>，因此这些线程都能<strong>访问相同的变量</strong>并在同一个堆上<strong>分配对象</strong>，这就需要实现一种比在进程间共享数据粒度更细的<strong>数据共享</strong>机制。如果没有明确的同步机制来协同对共享数据的访问，那么当一个线程正在使用某个变量时，另一个线程可能同时访问这个变量，这将造成不可预测的结果。</p><p>Java程序天生就是多线程程序：<strong>一个Java程序的运行时main线程和多个其他线程同时运行</strong>。</p><h4 id=线程的优势>线程的优势</h4><p>线程可以有效降低程序的开发和维护成本，同时提升复杂应用程序的性能。线程能够将大部分的异步工作流转换成串行工作流，因此能更好地模拟人类的工作方式和交互方式。</p><p>在GUI应用程序中，线程可以提高用户界面的响应灵敏度，而在服务器应用程序中，可以提升资源利用率以及系统吞吐率。线程还可以简化JVM的实现，垃圾收集器通常在一个或多个专门的线程中运行。在许多重要的Java应用程序中，都在一定程度上用到了线程。</p><h4 id=线程带来的风险>线程带来的风险</h4><ul><li>安全性问题</li><li>活跃性问题</li><li>性能问题</li></ul><h3 id=线程安全性>线程安全性</h3><p>并发的核心在于线程安全，什么是线程安全？</p><blockquote><p>线程安全是一个多线程环境下正确性的概念，也就是保证多线程环境下<strong>共享的</strong>、<strong>可修改的</strong>状态的正确性。</p><p>《Java并发编程实战》</p></blockquote><p>这里的状态可以反映在程序中其实可以看作是数据。换个角度来看，如果状态不是共享的，或者不是可修改的，也就不存在线程安全问题，所以，进而可以推理出保证线程安全的两个办法：封装(将对象内部状态隐藏保护起来，变得不可共享)，不可变（通过final或者immutable使状态不可变）。</p><p>线程安全需要保证几个基本特性：</p><ul><li><strong>原子性</strong>：简单来说就是相关操作不会中途被其他线程干扰，一般可通过同步机制实现。</li><li><strong>可见性</strong>：一个线程修改了某个共享变量，其他线程可以同步获取修改结果，通常被解释为将线程本地状态反映到主内存上，volatile就是负责保证可见性的。</li><li><strong>有序性</strong>：保证线程内串行语义，避免指令重排等。</li></ul><p><strong>解决原子性问题</strong></p><p>原子性问题的源头是线程切换，如果能够禁用线程切换就能从源头解决这个问题，而操作系统做线程切换是依赖cpu中断的，所以禁止CPU发生中断就能够禁止线程切换。在早期的单核CPU时代，这个方案是可行的，但在多核场景下，同一时刻，有可能有两个线程同时执行，此时禁止CPU中断，只能保证CPU上的线程连续执行，并不能保证同一时刻只有一个线程执行。</p><p><em><strong>同一个时刻只有一个线程执行</strong></em>，我们称之为<strong>互斥</strong>，如果能够保证对共享变量的修改是互斥的，那么，就能够保证原子性了。</p><p>互斥锁就是用来解决原子性问题的</p><h4 id=锁>锁</h4><p><img class=lazyload src=/svg/loading.min.svg data-src=https://static001.geekbang.org/resource/image/28/2f/287008c8137a43fa032e68a0c23c172f.png data-srcset="https://static001.geekbang.org/resource/image/28/2f/287008c8137a43fa032e68a0c23c172f.png, https://static001.geekbang.org/resource/image/28/2f/287008c8137a43fa032e68a0c23c172f.png 1.5x, https://static001.geekbang.org/resource/image/28/2f/287008c8137a43fa032e68a0c23c172f.png 2x" data-sizes=auto alt=https://static001.geekbang.org/resource/image/28/2f/287008c8137a43fa032e68a0c23c172f.png title=img></p><p>受保护资源和锁之间合理的关联关系应该是N:1的关系，也就是说可以用一把锁来保护多个资源，但是不能用多把锁来保护一个资源。</p><p>用不同的锁对受保护资源进行精细化管理，能够提升性能。这种锁称为<strong>细粒度锁</strong>。</p><h5 id=synchronized与reentrantlock>synchronized与ReentrantLock</h5><p>synchronized是Java内建的同步机制，它提供了互斥的语义和可见性，当一个线程已经获取当前锁时，其他试图获取的线程只能等待或者阻塞在那里。</p><p>ReentrantLock，通常翻译为再入锁，使Java5提供的锁实现。</p><p><strong>synchronized</strong></p><p>Java编译器会在synchronized修饰的方法或代码块前后自动加上加锁lock()和解锁uncheck()。</p><h5 id=如何用一把锁保护多个资源>如何用一把锁保护多个资源</h5><blockquote><p>受保护的资源和锁之间的合理的关联关系应该是N:1的关系</p></blockquote><p>一把锁可以保护多个资源，但不能用多个锁来保护一个资源。</p><p>我们可以用一把锁来保护多个资源，但会导致性能太差。用不同的锁对受保护的资源进行精细化管理，能够提升性能，这种锁被叫做<strong>细粒度锁</strong>。</p><h6 id=保护有关联关系的多个资源>保护有关联关系的多个资源</h6><p>如果多个资源是有关联关系的，那么这个问题就比较复杂了。</p><p>比如一个银行转账问题，A账户给B账户转账100元，在Account类中有一个transfer()的用于转账的方法。</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=kd>class</span> <span class=nc>Account</span> <span class=o>{</span> 
    <span class=kd>private</span> <span class=kt>int</span> <span class=n>balance</span><span class=o>;</span> <span class=c1>// 转账 
</span><span class=c1></span>    <span class=kt>void</span> <span class=nf>transfer</span><span class=o>(</span> <span class=n>Account</span> <span class=n>target</span><span class=o>,</span> <span class=kt>int</span> <span class=n>amt</span><span class=o>){</span> 
        <span class=k>if</span> <span class=o>(</span><span class=k>this</span><span class=o>.</span><span class=na>balance</span> <span class=o>&gt;</span> <span class=n>amt</span><span class=o>)</span> <span class=o>{</span> 
            <span class=k>this</span><span class=o>.</span><span class=na>balance</span> <span class=o>-=</span> <span class=n>amt</span><span class=o>;</span> 
            <span class=n>target</span><span class=o>.</span><span class=na>balance</span> <span class=o>+=</span> <span class=n>amt</span><span class=o>;</span> 
        <span class=o>}</span> 
    <span class=o>}</span> 
<span class=o>}</span>
</code></pre></div><p>我们可能会想到给transfer()方法加个synchronized修饰一下</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=kd>class</span> <span class=nc>Account</span> <span class=o>{</span>
  <span class=kd>private</span> <span class=kt>int</span> <span class=n>balance</span><span class=o>;</span>
  <span class=c1>// 转账
</span><span class=c1></span>  <span class=kd>synchronized</span> <span class=kt>void</span> <span class=nf>transfer</span><span class=o>(</span>
      <span class=n>Account</span> <span class=n>target</span><span class=o>,</span> <span class=kt>int</span> <span class=n>amt</span><span class=o>){</span>
    <span class=k>if</span> <span class=o>(</span><span class=k>this</span><span class=o>.</span><span class=na>balance</span> <span class=o>&gt;</span> <span class=n>amt</span><span class=o>)</span> <span class=o>{</span>
      <span class=k>this</span><span class=o>.</span><span class=na>balance</span> <span class=o>-=</span> <span class=n>amt</span><span class=o>;</span>
      <span class=n>target</span><span class=o>.</span><span class=na>balance</span> <span class=o>+=</span> <span class=n>amt</span><span class=o>;</span>
    <span class=o>}</span>
  <span class=o>}</span> 
<span class=o>}</span>
</code></pre></div><p>在这段代码中，临界区有两个资源：转出账户的余额<code>this.balance </code>和 转入账户的余额<code>target.balance</code>，并且用的是同一把锁this，看起来符合多个资源用同一把锁保护，但是，这个方案仅仅是看似正确的。</p><p>问题出在这个this这把锁上，this可以保护自己的资源(this.balance)，却保护不了其他人的资源(target.balance)。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://static001.geekbang.org/resource/image/1b/d8/1ba92a09d1a55a6a1636318f30c155d8.png data-srcset="https://static001.geekbang.org/resource/image/1b/d8/1ba92a09d1a55a6a1636318f30c155d8.png, https://static001.geekbang.org/resource/image/1b/d8/1ba92a09d1a55a6a1636318f30c155d8.png 1.5x, https://static001.geekbang.org/resource/image/1b/d8/1ba92a09d1a55a6a1636318f30c155d8.png 2x" data-sizes=auto alt=https://static001.geekbang.org/resource/image/1b/d8/1ba92a09d1a55a6a1636318f30c155d8.png title=img></p><h6 id=使用锁的正确姿势>使用锁的正确姿势</h6><p>那如何解决上面这个问题呢，只要我们的<strong>锁能覆盖所有受保护的资源</strong>就可以了。</p><p>因为this是对象级别的锁，所以A对象和B对象都有自己的锁，如何让A对象和B对象共享一把锁呢？</p><p>可以让所有对象都持有一个唯一性的对象：</p><ol><li><p>在创建Account对象时，传入一个对象，用于进行锁操作</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java>   
<span class=kd>class</span> <span class=nc>Account</span> <span class=o>{</span>
  <span class=kd>private</span> <span class=n>Object</span> <span class=n>lock</span><span class=err>；</span>
  <span class=kd>private</span> <span class=kt>int</span> <span class=n>balance</span><span class=o>;</span>
  <span class=kd>private</span> <span class=nf>Account</span><span class=o>();</span>
  <span class=c1>// 创建Account时传入同一个lock对象
</span><span class=c1></span>  <span class=kd>public</span> <span class=nf>Account</span><span class=o>(</span><span class=n>Object</span> <span class=n>lock</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>this</span><span class=o>.</span><span class=na>lock</span> <span class=o>=</span> <span class=n>lock</span><span class=o>;</span>
  <span class=o>}</span> 
  <span class=c1>// 转账
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>transfer</span><span class=o>(</span><span class=n>Account</span> <span class=n>target</span><span class=o>,</span> <span class=kt>int</span> <span class=n>amt</span><span class=o>){</span>
    <span class=c1>// 此处检查所有对象共享的锁
</span><span class=c1></span>    <span class=kd>synchronized</span><span class=o>(</span><span class=n>lock</span><span class=o>)</span> <span class=o>{</span>
      <span class=k>if</span> <span class=o>(</span><span class=k>this</span><span class=o>.</span><span class=na>balance</span> <span class=o>&gt;</span> <span class=n>amt</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>this</span><span class=o>.</span><span class=na>balance</span> <span class=o>-=</span> <span class=n>amt</span><span class=o>;</span>
        <span class=n>target</span><span class=o>.</span><span class=na>balance</span> <span class=o>+=</span> <span class=n>amt</span><span class=o>;</span>
      <span class=o>}</span>
    <span class=o>}</span>
  <span class=o>}</span>
<span class=o>}</span>
</code></pre></div><p>但这种方式的问题是它要求必须传入同一个对象，在真实的项目场景中，创建Account对象代码很可能分散在多个工程中，传入共享的lock不太现实。</p></li><li><p>用Account.class作为共享的锁</p><p>Account.class 是所有 Account 对象共享的，而且这个对象是 Java 虚拟机在加载 Account 类的时候创建的，所以我们不用担心它的唯一性，而且不用在创建对象时传入，可以直接使用</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java>   
<span class=kd>class</span> <span class=nc>Account</span> <span class=o>{</span>
  <span class=kd>private</span> <span class=kt>int</span> <span class=n>balance</span><span class=o>;</span>
  <span class=c1>// 转账
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>transfer</span><span class=o>(</span><span class=n>Account</span> <span class=n>target</span><span class=o>,</span> <span class=kt>int</span> <span class=n>amt</span><span class=o>){</span>
    <span class=kd>synchronized</span><span class=o>(</span><span class=n>Account</span><span class=o>.</span><span class=na>class</span><span class=o>)</span> <span class=o>{</span>
      <span class=k>if</span> <span class=o>(</span><span class=k>this</span><span class=o>.</span><span class=na>balance</span> <span class=o>&gt;</span> <span class=n>amt</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>this</span><span class=o>.</span><span class=na>balance</span> <span class=o>-=</span> <span class=n>amt</span><span class=o>;</span>
        <span class=n>target</span><span class=o>.</span><span class=na>balance</span> <span class=o>+=</span> <span class=n>amt</span><span class=o>;</span>
      <span class=o>}</span>
    <span class=o>}</span>
  <span class=o>}</span> 
<span class=o>}</span>
</code></pre></div></li></ol><p>下面这幅图很直观地展示了我们是如何使用共享的锁 Account.class 来保护不同对象的临界区的</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://static001.geekbang.org/resource/image/52/7c/527cd65f747abac3f23390663748da7c.png data-srcset="https://static001.geekbang.org/resource/image/52/7c/527cd65f747abac3f23390663748da7c.png, https://static001.geekbang.org/resource/image/52/7c/527cd65f747abac3f23390663748da7c.png 1.5x, https://static001.geekbang.org/resource/image/52/7c/527cd65f747abac3f23390663748da7c.png 2x" data-sizes=auto alt=https://static001.geekbang.org/resource/image/52/7c/527cd65f747abac3f23390663748da7c.png title=img></p><p>对于如何保护多个资源，关键要分析多个资源之间的关系。如果资源之间没有关系，每个资源各一把锁就好了，如果资源之间有关联关系，就要选择一个粒度更大的锁，这个锁能够覆盖所有的资源。</p><p>关联关系如果用更具体、更专业的语言来描述的话，其实就是一种"原子性"特征。</p><p>原子性的本质其实就是多个资源间有一致性要求，操作的中间状态对外不可见，所以解决原子性问题，是要保证中间状态对外不可见。</p><p>注意点：可变对象不能作为锁，比如用this.balance 和 this.password作为锁都是不可行的，因为它们都可以发生改变，当发生改变时，相当于换锁。</p><h5 id=死锁>死锁</h5><p>死锁：一组互相竞争资源的线程因互相等待，导致永久阻塞的现象。</p><h6 id=如何预防死锁>如何预防死锁</h6><p>死锁的四个条件：</p><ol><li>互斥，共享资源只能被一个线程占用</li><li>占有且等待，线程A在取得共享资源X，等待共享资源Y的时候，不释放共享资源X</li><li>不可抢占，其他线程不能强行抢占当前线程占有的资源</li><li>循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。</li></ol><p>我们只要破坏掉其中一个条件，就能避免死锁的发生了。</p><ol><li>互斥不能破坏，用锁就是为了互斥；</li><li>对于占有且等待，我们可以一次性申请所有的资源</li><li>对于不可抢占，占用部分资源的线程进一步申请其他资源时，如果申请不到，就可以主动释放它占用的资源</li><li>对于循环等待，可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不存在循环了。</li></ol><p>破坏不可抢占条件看上去很简单，核心是要能够主动释放它占有的资源，这一点 synchronized 是做不到的。原因是 synchronized 申请资源的时候，如果申请不到，线程直接进入阻塞状态了，而线程进入阻塞状态，啥都干不了，也释放不了线程已经占有的资源。</p><p>破坏这个条件，需要对资源进行排序，然后按序申请资源。这个实现非常简单，我们假设每个账户都有不同的属性 id，这个 id 可以作为排序字段，申请的时候，我们可以按照从小到大的顺序来申请。比如下面代码中，①~⑥处的代码对转出账户（this）和转入账户（target）排序，然后按照序号从小到大的顺序锁定账户。这样就不存在“循环”等待了</p><h5 id=等待-通知机制优化循环等待>等待-通知机制优化循环等待</h5><p>一个完整的等待-通知机制：<strong>线程获取互斥锁，当线程要求的条件不满足时，释放互斥锁，进入等待状态；当要求的条件满足时，通知等待的线程，重新获取互斥锁</strong>。</p><h6 id=synchronized实现等待-通知机制>Synchronized实现等待-通知机制</h6><p>Synchronized配合wait()、notify()、notifyAll()可以实现等待-通知机制</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://static001.geekbang.org/resource/image/c6/d0/c6640129fde927be8882ca90981613d0.png data-srcset="https://static001.geekbang.org/resource/image/c6/d0/c6640129fde927be8882ca90981613d0.png, https://static001.geekbang.org/resource/image/c6/d0/c6640129fde927be8882ca90981613d0.png 1.5x, https://static001.geekbang.org/resource/image/c6/d0/c6640129fde927be8882ca90981613d0.png 2x" data-sizes=auto alt=https://static001.geekbang.org/resource/image/c6/d0/c6640129fde927be8882ca90981613d0.png title=img></p><p>左边有一个等待队列，同一时刻，只允许一个线程进入synchronized保护的临界区，当有一个线程进入临界区后，其他线程就只能进入左边的等待队列里等待。这个等待队列和互斥锁是一对一的关系，每个互斥锁都有自己的等待队列。</p><p>当调用wait方法后，当前线程就会被阻塞，并且进入到右边的等待队列中，这个等待队列也是互斥锁的等待队列。线程在等待队列的同时，会释放当前持有的互斥锁，线程释放锁后，其他线程就有机会获得锁，并进入临界区了。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://static001.geekbang.org/resource/image/1b/8c/1b3e999c300166a84f2e8cc7a4b8f78c.png data-srcset="https://static001.geekbang.org/resource/image/1b/8c/1b3e999c300166a84f2e8cc7a4b8f78c.png, https://static001.geekbang.org/resource/image/1b/8c/1b3e999c300166a84f2e8cc7a4b8f78c.png 1.5x, https://static001.geekbang.org/resource/image/1b/8c/1b3e999c300166a84f2e8cc7a4b8f78c.png 2x" data-sizes=auto alt=https://static001.geekbang.org/resource/image/1b/8c/1b3e999c300166a84f2e8cc7a4b8f78c.png title=img></p><p>当条件满足时，调用notify()，会通知等待队列(互斥锁的等待队列)中的线程，告诉它条件曾经满足过。</p><p>notify() 只能保证在通知时间点，条件是满足的。而被通知线程的执行时间点和通知的时间点基本上不会重合，所以当线程执行的时候，很可能条件已经不满足了（保不齐有其他线程插队）</p><h4 id=线程问题总结>线程问题总结</h4><p>并发编程的问题，从宏观上来讲，主要在三个方面：<strong>安全性问题</strong>、<strong>活跃性问题</strong>、<strong>性能问题</strong></p><h5 id=安全性问题>安全性问题</h5><p>线程安全本质上就是正确性，也就是程序按照我们的期望执行。</p><p>引起线程安全的三个主要源头：<strong>原子性问题</strong>、<strong>可见性问题</strong>、<strong>有序性问题</strong>，理论上线程安全的问题，就要避免出现原子性问题、可见性问题和有序性问题。</p><p>其实只有一种情况会产生这些问题，就是<strong>存在共享数据并且该数据会发生变化，通俗地讲就是有多个线程会同时读写同一数据</strong>。那如果能够做到不共享数据或者数据状态不发生变化，不就能够保证线程的安全性了嘛。有不少技术方案都是基于这个理论的，例如线程本地存储（Thread Local Storage，TLS）、不变模式。</p><p>当多个线程同时访问同一数据，并且至少有一个线程会写这个数据的时候，叫做<strong>数据竞争</strong>。</p><p>还有个问题就是<strong>竞态条件</strong>，指的是程序的执行结果依赖线程执行的顺序。在并发环境里，线程的执行顺序是不确定的，如果程序存在竞态条件问题，那就意味着程序执行的结果是不确定的，而执行结果不确定这可是个大 Bug。</p><p>对于数据竞争和竞态条件问题，都可以使用<strong>互斥</strong>的技术方案，也就是<strong>锁</strong>。</p><h5 id=活跃性问题>活跃性问题</h5><p>所谓的活跃性问题，指的是某个操作无法执行下去。<strong>死锁</strong>就是一种典型的活跃性问题，除了死锁外，还有两种情况，分别是<strong>活锁</strong>和<strong>饥饿</strong>。</p><p>发生“死锁”后线程会互相等待，而且会一直等待下去，在技术上的表现形式是线程永久地“阻塞”了。</p><p>有时线程虽然没有发生阻塞，但仍然会存在执行不下去的情况，这就是所谓的“活锁”。解决死锁的方案就是尝试等待一个随机的时间。“等待一个随机时间”的方案虽然很简单，却非常有效，Raft 这样知名的分布式一致性算法中也用到了它。</p><p>所谓“饥饿”指的是线程因无法访问所需资源而无法执行下去的情况。</p><p>解决饥饿问题的方案有三种：</p><ul><li>保证资源充足</li><li>公平地分配资源</li><li>避免持有锁的线程长时间执行</li></ul><p>这三种方案中，方案一和方案三的适用场景比较有限，因为很多场景下，资源的稀缺性是没有办法解决的，持有锁的线程执行的时间也很难缩短，所以方案二的适用场景相对来说更多一些。</p><p>公平地分配资源，在并发编程里，主要是使用公平锁。所谓公平锁，就是一种先来后到的方案，线程的等待是有顺序的，排在等待队列前面的线程会优先获得资源。</p><h5 id=性能问题>性能问题</h5><p>使用锁时，如果过度使用，可能会出现性能问题。</p><p>如何来解决锁导致的性能问题？</p><p>第一，既然使用锁会带来性能问题，那最好的方案自然就是使用无锁的算法和数据结构了。在这方面有很多相关的技术，例如线程本地存储 (Thread Local Storage, TLS)、写入时复制 (Copy-on-write)、乐观锁等；Java 并发包里面的原子类也是一种无锁的数据结构；Disruptor 则是一个无锁的内存队列，性能都非常好……</p><p>第二，减少锁持有的时间。互斥锁本质上是将并行的程序串行化，所以要增加并行度，一定要减少持有锁的时间。这个方案具体的实现技术也有很多，例如使用细粒度的锁，一个典型的例子就是 Java 并发包里的 ConcurrentHashMap，它使用了所谓分段锁的技术；还可以使用读写锁，也就是读是无锁的，只有写的时候才会互斥。</p><p>性能的度量指标很多，有三个非常重要：吞吐量、延迟和并发量。</p><p>吞吐量：指的是单位时间内能处理的请求数量。吞吐量越高，说明性能越好。</p><p>延迟：指的是从发出请求到收到响应的时间。延迟越小，说明性能越好。</p><p>并发量：指的是能同时处理的请求数量，一般来说随着并发量的增加、延迟也会增加。所以延迟这个指标，一般都会是基于并发量来说的。例如并发量是 1000 的时候，延迟是 50 毫秒。</p><h4 id=管程>管程</h4></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2021-03-30</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/java%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1/ class=prev rel=prev title=Java引用对象><i class="fas fa-angle-left fa-fw"></i>Java引用对象</a>
<a href=/posts/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/ class=next rel=next title=面试记录>面试记录<i class="fas fa-angle-right fa-fw"></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.81.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i>LoveIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2021</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank></a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i></a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>