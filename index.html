<!doctype html><html lang=zh-cn><head><meta name=generator content="Hugo 0.81.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>arvin's blog</title><meta name=Description content><meta property="og:title" content="arvin's blog"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://wzliy.github.io/"><meta name=twitter:card content="summary"><meta name=twitter:title content="arvin's blog"><meta name=twitter:description content><meta name=application-name content="arvin's blog"><meta name=apple-mobile-web-app-title content="arvin's blog"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://wzliy.github.io/><link rel=alternate href=/index.xml type=application/rss+xml title="arvin's blog"><link rel=feed href=/index.xml type=application/rss+xml title="arvin's blog"><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","url":"https:\/\/wzliy.github.io\/","inLanguage":"zh-CN","name":"arvin's blog"}</script></head><body header-desktop header-mobile><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':''==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:''==='dark')&&document.body.setAttribute('theme','dark')</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="arvin's blog">arvin's blog</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="arvin's blog">arvin's blog</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class="page home" posts><div class=home-profile></div><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/mysql/>MySQL</a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>arvin</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=2021-04-13>2021-04-13</time></span></div><div class=content>索引 MySQL索引的出现其实就是为了提高数据的查询效率
索引的常见模型
哈希表 有序数组 索引树 索引树 B树
B树的特征:
关键字集合分布在整棵树中 任何一个关键字出现且只出现在一个节点中； 搜索有可能在非叶子节点结束 创建高性能的索引 索引存储在引擎层，而不是服务器层。所以，不同的存储引擎的索引的工作方式并不一样。</div><div class=post-footer><a href=/posts/mysql/>阅读全文</a></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/redis/>Redis</a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>arvin</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=2021-04-13>2021-04-13</time></span></div><div class=content>redis内核探究</div><div class=post-footer><a href=/posts/redis/>阅读全文</a></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/springcloud%E4%B9%8Bfeign/>Spring Cloud之Feign</a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>arvin</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=2021-04-13>2021-04-13</time></span></div><div class=content>Feign的自定义配置 Feign自定义日志级别 级别 打印内容 NONE(默认值) 不记录任何日志 BASIC 仅记录请求方法、URL、响应状态码以及执行时间 HEADERS 记录BASIC的基础上，记录请求和响应的header FULL 记录请求和响应的header、body和元数据 配置方式 Java代码方式
新建configuration
public class UserCenterFeignConfiguration { } 创建bean
public class UserCenterFeignConfiguration { @Bean public Logger.Level level() { return Logger.Level.FULL; } } FeignClien注解上加上configuration配置
@FeignClient(name = "user-center", configuration = UserCenterFeignConfiguration.class) public interface UserCenterFeignClient { ...... } application.</div><div class=post-footer><a href=/posts/springcloud%E4%B9%8Bfeign/>阅读全文</a></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/springcloud%E4%B9%8Brabbon/>Spring Cloud之Ribbon</a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>arvin</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=2021-04-13>2021-04-13</time></span></div><div class=content>Ribbon Ribbon是一个消费端的负载均衡处理器。
首先看一段代码：
// 调用user-center获取user List&lt;ServiceInstance> instances = discoveryClient.getInstances("user-center"); List&lt;String> serviceIps = instances.stream() .map(instance -> instance.getUri().toString()).collect(Collectors.toList()); int i = ThreadLocalRandom.current().nextInt(serviceIps.size()); log.info("请求服务的目标ip: {}", serviceIps.get(i)); String result = restTemplate.getForObject(url, String.class, share.getUserId()); 这段代码是用来通过注册中心获取服务的地址列表，然后随机选取一个地址来进行服务调用。
我们可以使用Ribbon来简化这个过程：
@Bean @LoadBalanced public RestTemplate restTemplate(){ return new RestTemplate(); } String url = "http://user-center/notes/user/{id}"; String result = restTemplate.getForObject(url, String.class, share.getUserId()); 在RestTemplate的Bean上加上注解LoadBalanced
在url中写上服务名，可直接调用该服务
我们将Ribbon做的事分解一下：
通过服务名获取注册中心的服务地址 通过负载均衡规则，选择服务实例 Ribbon的组成
接口 作用 默认值 IClientConfig 读取配置 IRule 负载均衡规则，选择实例 IPing 筛选掉ping不通的实例 ServerList 交给Ribbon的实例列表 ServerListFilter</div><div class=post-footer><a href=/posts/springcloud%E4%B9%8Brabbon/>阅读全文</a></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/tomcat%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/>Tomcat核心原理</a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>arvin</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=2021-04-13>2021-04-13</time></span></div><div class=content>Tomact</div><div class=post-footer><a href=/posts/tomcat%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/>阅读全文</a></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/about/>关于</a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>arvin</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=2021-04-13>2021-04-13</time></span></div><div class=content>这里是arvin的博客记录</div><div class=post-footer><a href=/posts/about/>阅读全文</a></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91/>数据结构之二叉树</a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>arvin</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=2021-04-13>2021-04-13</time></span></div><div class=content>树</div><div class=post-footer><a href=/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91/>阅读全文</a></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/>消息队列</a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>arvin</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=2021-04-13>2021-04-13</time></span></div><div class=content>消息队列 消息对象应用场景 消息模型 消息事务 消息队列中的事务，主要解决的是消息生产者和消费者数据一致性问题。
事务是指如果我们需要对若干数据进行更新操作，为了保证这些数据的完整性和一致性，我们希望这些更新操作要么都成功，要么都失败。
事务有四大特性：
原子性：一个事务中的操作不可分割， 一致性：这些数据在事务执行这个完成时间点之前，读到的一定是事务执行前的数据，之后读到的一定是事务执行更新后的数据，不可能存在读取事务更新过程中的数据 隔离性：一个事务的执行不能被其他事务干扰 持久性：一个事务一旦完成提交，后续的其他操作和故障都不会对事务的结果产生任何影响 分布式事务 分布式系统中，严格的实现ACID这四个特性几乎是不可能的，实现代价太大，大到我们无法接受
目前大家所说的分布式事务，更多情况下，是在分布式系统中事务的不完整实现。在不同的应用场景中，有不同的实现，目的都是通过一些妥协来解决实际问题。在实际应用中，比较常见的分布式事务实现有 2PC（Two-phase Commit，也叫二阶段提交）、TCC(Try-Confirm-Cancel) 和事务消息。每一种实现都有其特定的使用场景，也有各自的问题，都不是完美的解决方案。
事务消息适用于那些需要异步更新数据，并且对数据实时性要求不太高的场景。
消息队列实现事务消息 事务消息需要消息队列提供相应的事务功能才能实现，Kafka 和 RocketMQ都提供了事务相关功能。
举例说明，订单和购物车系统
订单系统在消息队列上开启一个事务，然后，订单系统发送一个"半消息"到消息服务，这个半消息在消费端暂时不可见，当订单系统执行完本地事务成功后，再通知消息队列提交事务，消息队列才将这个消息转成消费端可消费的消息。
如果第四步提交事务消息时失败如何处理？
Kafka: 抛出异常，用户自行处理
RocketMQ：通过事务反查机制，如果在提交或者回滚事务消息时发生网络异常，RocketMQ的Broker没有收到提交或者回滚的请求，Broker会定期去反查这个事务对应的本地事务的状态，然后根据这个反查的结果决定提交或者回滚这个事务，所以，我们的业务中需要提供一个事务状态反查的接口
RocketMQ提交消息的步骤:
发送Half消息 判断Half消息发送成功 执行本地事务 提交本地事务执行结果 消息队列确认本地事务提交结果，如果未收到本地事务执行的结果，回查事务状态 通过回查事务状态接口检查本地事务 根据本地事务状态结果提交事务到消息队列 消息队列根据本地事务状态结果投递或者回滚消息 消息丢失问题 现在主流的消息队列都提供了非常完善的消息可靠性保证机制，完成可以做到，在消息传递过程中，即使发生网络中断或者硬件故障，也能确保消息的可靠传递，不丢消息。
检测消息丢失的办法 可以通过消息队列的有序性来检测消息是否丢失。原理非常简单，在 Producer 端，我们给每个发出的消息附加一个连续递增的序号，然后在 Consumer 端来检查这个序号的连续性。
实现时可利用拦截器机制，在发送消息之前的拦截器中将序号注入到消息中，在消费端消费消息的拦截器中检测序号的连续性，这样实现的好处是消息检测的代码不会侵入到你的业务代码中。
确保消息可靠传递 生产阶段: 在这个阶段，从消息在 Producer 创建出来，经过网络传输发送到 Broker 端。
存储阶段: 在这个阶段，消息在 Broker 端存储，如果是集群，消息会在这个阶段被复制到其他的副本上。
消费阶段: 在这个阶段，Consumer 从 Broker 上拉取消息，经过网络传输发送到 Consumer 上。</div><div class=post-footer><a href=/posts/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/>阅读全文</a></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/>网络通信</a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>arvin</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=2021-04-13>2021-04-13</time></span></div><div class=content>互联网的核心是一系列协议，总称"网络协议"。它们对电脑如何连接和组网，做出了详尽的规定。理解了这些协议，就理解了互联网原理。</div><div class=post-footer><a href=/posts/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/>阅读全文</a></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/>面试记录</a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>arvin</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=2021-04-13>2021-04-13</time></span></div><div class=content>面试遇到问题记录
Spring Boot与Spring Cloud的区别 Spring Cloud的组成 怎么识别哪些数据需要缓存到Redis Maven怎么解决依赖冲突 如何优化Sql Mysql索引的数据结构 Mysql索引有什么缺点(比如一张表有十个字段，给十个字段都建立索引有什么问题) 分库如何查询的 多线程怎么使用的 Spring Boot 启动原理
自定义启动类
双亲委派机制
Spring Bean的生命周期
对象创建的过程
垃圾回收算法
自定义类加载器
Redis的哨兵机制
Kafka底层原理
通过索引，怎么查询数据
项目中有没有用到Spring Aop
Spring Aop的实现原理
面试整理 集合 经常用到哪些 Map 这几种 Map 的区别 CocurrentHashMap 怎么保证线程安全 CocurrentHashMap 在 JDK 1.</div><div class=post-footer><a href=/posts/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/>阅读全文</a></div></article><ul class=pagination><li class="page-item active"><span class=page-link><a href=/>1</a></span></li><li class=page-item><span class=page-link><a href=/page/2/>2</a></span></li></ul></div></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.81.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i>LoveIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2021</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank></a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i></a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>