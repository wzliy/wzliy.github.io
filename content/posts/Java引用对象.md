---
title: "Java引用对象"
author: arvin
date: 2021-03-28T21:39:35+08:00
draft: false
---



> 我该如何学会停止担心OutOfMemoryError



### Java堆和对象的生命周期

对于一个从C++到Java的新程序员来说，堆和栈之间的关系可能很难掌握。在C++中，对象可以通过new的操作在堆上创建，也可以使用自动分配在栈上创建。以下是C++的程序：它在栈上创建了一个新对象。但是，Java编译器

会报错。

```C++
Integer foo = Integer(1);
```

Java不同于c++，所有的对象都存储于堆中，它需要通过`new`操作来创建对象。本地变量仍存储在栈上，但存储的是指向对象的指针，而不是对象本身（当然，为了与C++程序区分，这些指针被称为引用）。思考下面的Java方法，有一个Integer的变量引用了一个从String转换过来的值：

```java
public static void foo(String bar) {
    Integer baz = new Integer(bar);
}
```

下图显示了此方法的堆和栈之间的关系。栈被分为一个个的栈帧，栈帧中包含了每个方法的参数和局部变量。这些变量都指向了对象--在本例中，参数`bar`和局部变量`baz`指向了存活在堆中的对象。

![stack_and_heap](/jvm/stack_and_heap.gif)

现在更仔细的观察`foo()`的第一行，分配了一个新的Integer对象。在幕后，JVM首先尝试为此对象找到足够的堆空间(在32位的JVM上大概是12字节)。如果能够分配空间，则调用构造器，该构造器解析已通过的字符串并初始化新分配的对象。最后JVM将指向这个对象的指针保存在变量`baz`中。

这就是"快乐之路"，有几个不太快乐的地方，其中一个就是，我们关心的是当`new`操作不能为这个对象找到12个字节的空间时怎么处理。在这种情况下，放弃和抛出OutOfMemoryError之前，它将调用垃圾收集器，试图腾出空间。

### 垃圾收集器

虽然Java提供了一个`new`操作来分配堆上的对象，但它没有提供相应的操作来删除它们。当`foo()`方法返回时，这个`baz`变量超出了范围，但它指向的对象仍然存在于堆上。如果这是故事的结尾，那么所有的程序都会很快耗尽内存。然而，Java提供了一个垃圾收集器，以便在不再引用这些对象后进行清理。

当程序尝试创建新对象而在堆中没有足够的空间时，垃圾收集器开始工作。请求线程暂停，收集器通过查看堆空间，试图找到不再积极使用的程序对象，并回收其空间。如果收集器无法释放足够的空间，而JVM无法扩展堆，那么`new`操作将抛出OutOfMemoryError异常。这通常伴随着你的程序关闭。

#### 标记扫描

Java的一个持久的神话围绕着垃圾收集器。许多人认为，JVM保存了每个对象的引用次数，而收集器只查看引用次数为零的对象。实际上，JVM使用了一种称为"标记扫描(Mark-sweep)"的技术。标记扫描垃圾收集背后的理念很简单：程序无法到达的每个对象都是垃圾，并且有资格收集。

标记扫描收集有以下阶段：

**第1阶段：标记**

垃圾收集器从"root"引用开始，穿过标有其到达的所有对象的对象图。

![gc_mark](/jvm/gc_mark.gif)

**第2阶段：扫描**

任何在第一阶段没有标记的对象都是无法到达的，因此是垃圾对象。如果垃圾对象定义了fanalizer,则将其添加到finalization queue中。如果没有，则将其空间进行重新分配(具体含义取决于具体的GC实施，并且有许多实现)。

![gc_sweep](/jvm/gc_sweep.gif)

**第3阶段：压缩(可选)**

有些垃圾收集器有第三步：压缩。在此步骤中，GC移动对象用来汇集垃圾回收后留下的自由空间。这个可以防止堆空间变得支离破碎导致的分配大量连续空间失败。

例如，hotspot JVM 在新生代中使用压缩收集器，但在其老年代中使用非压缩收集器(至少在1.6和1.7版本)。

![gc_compact](/jvm/gc_compact.gif)

#### root引用

那么，"root"是什么？在一个简单的Java应用程序中，它们是方法参数和本地变量(存储在栈上)，当前执行表达式的操作（也存储在栈上）和静态类成员变量。

在使用自己的类加载器的程序中，含义变得模糊不清：只有被系统的类加载器加载的类包含root引用(JVM启动时使用的加载器)。应用程序创建的任何类加载器本身都会受到垃圾收集器的约束，一旦没有更多的引用指向他们。这就是允许应用服务器进行热部署的原因：它们为每个已部署的应用程序创建一个单独的类加载器，并在应用程序未部署或重新部署时放弃类加载器的引用。

了解root引用很重要，因为它定义了什么是"强"引用: 如果你能够遵循从root到特定对象的引用链，则该对象被"强烈"引用。它不会被垃圾回收。

因此，回到`foo()`方法，`bar`参数和`baz`局部变量只有在方法执行时才具有强引用，一旦方法完成，它们都脱离了范围，他们引用的对象都有资格被垃圾收集。或者，`foo()`方法可以返回一个它创建的`Integer`引用，这意味着该对象仍将被调用`foo()`的方法强烈引用。

现在考虑以下事项：

```java
LinkedList foo = new LinkedList();
foo.add(new Integer(123));
```

变量foo是一个指向LinkList对象的root引用。linked list里面有零个或多个列表元素，每个元素都指向其后续内容。当我们调用add()方法时，我们添加了一个新的列表元素，该列表元素指向具有值123的实例。这是一个强的引用链，这意味着垃圾收集器不会收集它们。然而，一旦foo 超出了范围，LinkedList和它里面的所有东西都能被回收了--当然，只要没有其他的强引用指向它。

你可能想知道，如果你有一个循环引用，会发生什么情况：对象A包含一个对象B的引用，其中包含返回A的引用。答案是，标记扫描收集器不会被愚弄：如果A和B都无法通过一系列的强引用到达，那么他们都能够被收集。

#### Finalizers

C++允许对象定义一个清理方法：当对象脱离了作用域或被明确删除时，这个清理方法被调用用来清理其使用的资源。对于大多数对象，这意味着明确的释放通过new或者malloc分配对象的任何内存。在Java中，垃圾收集器为你清理内存，因此无需明确的清理方法来处理此操作。

但是内存并不是唯一的需要清理的资源。想想FileOutputStream: 当你创建这个对象的实例的时候，它会从操作系统分配文件句柄。如果你在关闭流之前让流的所有引用都退出作用域，该文件句柄会发生什么情况呢？答案是，流有一个Finalizer 方法：在垃圾收集器回收对象之前调用的一个方法。在这个FileOutputStream的例子中，finalizer方法关闭流，将文件句柄释放回操作系统，并冲洗任何缓冲区，确保所有数据都正确地写入磁盘。

任何对象都可以有finalizers: 你所需要做的就是声明finalize() 方法：

```java
protected void finalize() throws Throwable {
    // cleanup your object here
}
```

虽然finalizers似乎是一种简单的处理方法在清理对象之后，但是，他们还是有一些严重的限制。首先，你不应该依赖他们来获取任何重要的东西，因为对象的finalizers可能永远不会被调用--应用程序可能会在垃圾收集器开始清理对象的时候退出。还有一些其他的，finalizers的更微妙的问题，稍后我们会在幻象引用的时候来讨论它。

#### 对象生命周期

综上所示，一个对象的生命周期可以通过下图简单的概括：它被创建，它被使用，它变得有资格被收集，并最终它被收集。阴影区域表示对象"强烈可到达"的时间，与引用对象提供的可达性相比，这个术语变得非常重要。

![object_life_cycle](/jvm/object_life_cycle.gif)

### 引用对象









